https://roadmap.sh/javascript


*****************************************************************************************************************************************************
Primitives:
	All the normal (bigint, boolean, etc...)
	undefined: default value for variables declared.
	Symbol: built-in object whose constructor returns a symbol that's guaranteed to be unique (often used to add unique property keys to an object that won't collide with keys any other code might add to the object). Every Symbol() call is guaranteed to return a unique Symbol. Every Symbol.for("key") call will always return the same Symbol for a given value of "key". Symbols are garbage collectable. To create Symbols available across files and even across realms (each of which has its own global scope), use the methods Symbol.for() and Symbol.keyFor() to set and retrieve Symbols from the global Symbol registry.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Objects

Generalities
	Objects are used to store keyed collections of various data and complex entities.
	Can be created with "{ ... }" (literal) or "new Object()" (constructor) with an optional list of properties (“key: value” pair) comma separated.
	Property values are accessible using the dot notation: object.property
	To remove a property, use the delete operator: delete object.property;
	Multiword property names are posible, but must be quoted. For this, the dot access doesn’t work: object.multiword property -> error. So use object["multiword property"]
	Square brackets also provide a way to obtain the property name as the result of any expression: let key = "likes birds"; user[key] = true; The dot notation cannot be used in a similar way: let key = "name"; console.log(user.key) -> undefined

Computed properties
	When you use square brackets in an object literal, when creating an object:
		let fruit = "apple";
		let bag = { [fruit]: 5, };
		bag.apple -> 5
	Computed properties means that, if [fruit] is used, the property name should be taken from fruit.
	Essentially, that works the same as:
		let fruit = "apple";
		let bag = {};
		bag[fruit] = 5;

Property value shorthand
	The use-case of making a property from a variable is so common, that there’s a special "property value shorthand" to make it shorter.
	Instead of {name: name, age: age,} -> {name, age}

Property names limitations
	A variable cannot have a name equal to one of the language-reserved words, but for an object property, there’s no such restriction.
	Other types are automatically converted to strings. (so you can write 0: "..." instead of "0":"...").
	There’s a minor gotcha with a special property named __proto__. We can’t set it to a non-object value. (See "Object prototypes" below)

Property existence test, “in” operator
	It’s possible to access any property. There's no error if the property doesn’t exist it just returns undefined.
	So there’s a special operator "in" for checking if a property exists. The syntax is: "key" in object (if quotes ommited, the var should contain the actual name to be tested)
	On the left side of in there must be a property name, on the right is the object.

The "for in" loop
	To walk over all keys of an object, there exists a special form of the loop: for in. Syntax is: for key in object {...}
	Example:
		for (let key in user) {
			key			-> name, age, etc
			user[key]	-> "Jhon Doe", 35, etc
		}

Ordered like an object
	Are objects ordered? The short answer is: “ordered in a special fashion”: integer properties (a string that can be converted to-and-from an integer without a change) are sorted, others appear in creation order.
	If the keys are non-integer, then they are listed in the creation order.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Object prototypes
	Prototypes are the mechanism by which JavaScript objects inherit features from one another.

The prototype chain
	Every object in JavaScript has a built-in property, which is called [[Prototype]]. But this property is hidden, so you can only access it with certain words / methods (see "Setting a prototype" below). The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has null for its own prototype.
	When accessing a property of an object: if the property can't be found in the object itself, the prototype is searched for the property. If it still can't be found, then the prototype's prototype is searched, and so on until the property is found or the end of the chain is reached (undefined is returned).
	Object.prototype is the most basic prototype, that all objects have by default. The prototype of Object.prototype is null (end of the chain).
	It's possible to mutate any member of the chain or even swap out the prototype at runtime, so concepts like static dispatching (extra below) don't exist in JavaScript.

------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------- Extra
static dispatch is a form of polymorphism fully resolved during compile time. It is a form of method dispatch, which describes how a language or environment will select which implementation of a method or function to use.
------------------------------------------------------------------------------------------------------------------------------------------------

Shadowing properties
	This is when you define a property in an object, when a property with the same name is defined in the object's prototype.
	Example: (Object.prototype has the toString() method)
			let obj = {name: "Jhon", greet {console.log("hello")} } -> obj.toString() = [object Object]
			obj.toString = () => "Name:" + obj.name; -> obj.toString() = Name: Jhon

Setting a prototype
	There are a lot of ways to do it: Object.create() and constructors.
		Using syntax constructs you can directly set the property __proto__ to a value (supported in all modern engines).
			const p = { b: 2, __proto__: o };
		When you call a function as a constructor, this property is set as the prototype of the newly constructed object.
			const personPrototype = {greet() {console.log("hello my name is", this.name);}};
			function Person (name) {this.name = name;}
		Object.create() creates a new object and lets you specify an object that will be the new object's prototype.
			const personPrototype = {greet() {console.log("hello");}};
			const carl = Object.create(personPrototype);
			carl.greet() -> hello
			Object.assign(Person.prototype, personPrototype) or Person.prototype.greet = personPrototype.greet
			Now every time a Person object is created (new Person("name")) it will have the .greet() method (__proto__ should not be confused with the func.prototype property of functions, which instead specifies the [[Prototype]] to be assigned to all instances of objects created by the given function when used as a constructor).
		With classes, since the actual implementation of classes inheritance is with this prototype model:
			class Square { constructor(size) {this.size = size;}}
			class FilledSquare { constructor(size, color) {this.size = size; this.color = color;}}
			const fs = new FilledSquare(5, "blue"); -> fs ---> FilledSquare.prototype ---> Square.prototype ---> Object.prototype ---> null
		With Object.setPrototypeOf() you can mutate the [[Prototype]] internal property of an existing object.
			const obj = { a: 1 };
			const anotherObj = { b: 2 };
			Object.setPrototypeOf(obj, anotherObj);
		All objects inherit the Object.prototype.__proto__ setter, which can be used to set the [[Prototype]] of an existing object (deprecated, you should almost always use Object.setPrototypeOf instead.)
			obj.__proto__ = somePrototype;
	It's common to see this pattern, in which methods are defined on the prototype, but data properties are defined in the constructor.
	Properties that are defined directly in the object, are called "own properties", and you can check whether a property is an own property using Object.hasOwn():
		const irma = new Person("Irma");
		console.log(Object.hasOwn(irma, "name")); -> true
		console.log(Object.hasOwn(irma, "greet")); -> false
	Properties that are defined in the prototype of the object are inherited.

Prototypes and inheritance
	Prototypes support a version of inheritance. If two objects have another one prototypes, then they can inherit the common properties, while adding and redefining those properties which need to differ (see Prototypal Inheritance below).
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Prototypal Inheritance
	With the prototypical inheritance model is fairly trivial to build a classic model on top of a prototypical model. That's actually how classes are implemented.
	Classes are now widely adopted, but they do not bring a new inheritance pattern, they just abstract most of the prototypical mechanism away.

Inheritance with the prototype chain
	Inheriting properties
		In an object literal like { a: 1, b: 2, __proto__: c }, the value c (has to be null or an object) will become the [[Prototype]] of the object, while the other keys (a & b) will become the own properties of the object.
		Setting a property to an object creates an own property.
	Inheriting methods
		JS doesn't have "methods" like class-based languages define them. In JS, any function can be added to an object in the form of a property.
		An inherited function acts just as any other property.
		When an inherited function is executed, the value of "this" points to the inheriting object, not the prototype object where the function is an own property.

Constructors
	Constructors are functions called with new.
	Use a constructor function to automatically set the [[Prototype]] for every object manufactured.
		function Box(value) {this.value = value;}
		Box.prototype.getValue = function () {return this.value;};
		const b = new Box(1)
		Now every instance created with new Box(value) will have the getValue method. But because this references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating Box.prototype (even the ones that are already instanciated. e.g. changing Box.prototype.getValue will alter the getValue function on b even if b is untouched).
	Constructor.prototype by default has one own property: constructor, which references the constructor function itself, meaning Box.prototype.constructor === Box. This allows one to access the original constructor from any instance.
	When you create a class, the methods are created on Class.prototype directly (Classes are syntax sugar over constructor functions)
		class Box {
			constructor(value) {this.value = value;}

			// Methods are created on Box.prototype
			getValue() {return this.value;}
		}
	A corollary is (re-assigning Constructor.prototype) a bad idea for two reasons:
		The [[Prototype]] of instances created before the reassignment are now referencing a different object from the [[Prototype]] of instances created after the reassignment.
		Unless you manually re-set the constructor property, the constructor function can no longer be traced from instance.constructor, which may break user expectation.

Implicit constructors of literals
	Since this: let a = [1, 2, 3] is = to this: let a = new Array(1, 2, 3), one can expect that some literals have a default prototype (in this case Array.prototype [which has the indexOf() function for example]).
------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------- Extra
There is one misfeature that is extending Object.prototype or one of the other built-in prototypes. An example of this misfeature is, defining Array.prototype.myMethod = function () {...} and then using myMethod on all array instances. This misfeature is called monkey patching. This risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break.
------------------------------------------------------------------------------------------------------------------------------------------------

Building longer inheritance chains
	By default, Constructor.prototype is a plain object and the Object.prototype [[Prototype]] is null, i.e. Constructor.prototype -> Object.protorype -> null
	To build longer prototype chains, we can set the [[Prototype]] of Constructor.prototype via the Object.setPrototypeOf() function. In class terms, this is equivalent to using the extends syntax.
		function Something () {}
		function SomethingElse () {}
		Object.setPrototypeOf(Something. SomethingElse) => Something.prototype -> SomethingElse.prototype -> Constructor.prototype -> Object.protorype -> null

Inspecting prototypes: a deeper dive
	All functions have a special property named prototype, except arrow functions.
	It's possible to add properties to the prototype of a function.
	Now you can use the new operator to create an instance of the function based on the prototype.
	Calling a function with the new operator returns an object that is an instance of the function. Properties can then be added onto this object.

Performance
	Trying to access nonexistent properties will always traverse the full prototype chain.
	When iterating over the properties of an object, EVERY property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, use hasOwnProperty or Object.hasOwn methods. It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Type Casting
	Type conversion
		Transfer of data from one data type to another.

	Type coercion
		Automatic or implicit conversion of values from one data type to another.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Data Structures
	Keyed Collections: collections of data which are indexed by a key.
		Maps
			Simple key/value object and iteratetable in insertion order.
			You can use a for...of loop to return an array of [key, value] for each iteration.
			Traditionally, objects have been used to map strings to values. Map objects, however, have a few more advantages:
				The keys of an Object are Strings or Symbols, where they can be of any value for a Map.
				You can get the size of a Map easily, while you have to manually keep track of size for an Object.
				The iteration of maps is in insertion order of the elements.
				An Object has a prototype, so there are default keys in the map. (This can be bypassed using map = Object.create(null).)
		WeakMaps
			Collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any type, and which does not create strong references to its keys. i.e. an object's presence as a key in a WeakMap does not prevent the object from being garbage collected.
			Once an object used as key has been collected, its value in any WeakMap becomes candidate for garbage collection as well.
			A WeakMap doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a WeakMap.
		Sets
			Collections of unique values of any type.
			You can iterate its elements in insertion order.
			Converting between Array and Set: use Array.from or the spread syntax to go from Set to Array, or the Set to go from Array to Set.
		WeakSets
			Collections of garbage-collectable values, including only objects and non-registered symbols.
			If there is no other reference to an object stored in the WeakSet, they can be garbage collected.
			WeakSets are not enumerable.
		Both the key equality of Maps and the value equality of Sets are based on the SameValueZero algorithm (see Equality Comparisons below).

	Indexed Collections: collections of data which are ordered by an index value.
		Arrays (omiting usual info common to every prog. lang.)
			You can create an array in 3 ways:
				new Array(1,2...)
				Array(1,2...)
				[1,2...]			(this syntax is called "array literal" or "array initializer")
			This creates an array with only one element, the number 42: const arr = [42];
			This creates an empty array with length 42: const arr = []; arr.length = 42;
			Writing a value that is shorter than the number of stored items truncates the array. Writing 0 empties it entirely.
			The forEach() method provides a way of iterating over an array: arr.forEach(...)
			Arrays can contain "empty slots" (this are called "sparse arrays"), which are not the same as slots filled with the value undefined.
			Arrays can also be used like objects, to store related information: const arr = [1, 2, 3]; arr.property = "value";
			Some objects look and behave like arrays on the surface but do not share all of their methods. This are array-like objects.
			Array methods cannot be called directly on array-like objects. But you can call them indirectly using Function.prototype.call().
				Array.prototype.forEach.call(yourArrayLikeObject, (item) => { ... })
			Array prototype methods can be used on strings as well, since they provide sequential access to their characters.
		Typed Arrays(similar to arrays in many ways)
			Array-like objects that provide a mechanism for reading and writing raw binary data in memory buffers.
			Each entry in a typed array is a raw binary value in one of the supported formats, from 8-bit integers to 64-bit floating-point numbers.
			Calling Array.isArray() on a typed array returns false.
			To achieve maximum flexibility and efficiency, JavaScript typed arrays split the implementation into buffers and views.
				A buffer (ArrayBuffer object) is an object representing a chunk of data; it has no format to speak of, and offers no mechanism for accessing its contents. To access it, you need to use a view. ArrayBuffer is a fixed-length binary data buffer.
				A view provides a context, i.e data type; starting offset; number of elements, that turns the data into an actual typed array. This object access the buffer allowing you to read/write in it.
			There are two types of views:
				Views that act like single-type arrays to a segment of an ArrayBuffer. This ones have self-descriptive names and provide views for all the usual numeric types (like Uint8Array, Float32Array, etc). This typed arrays use the endianness of the CPU.
				The DataView object that it is meant for handling heterogeneous data. the DataView object provides you a get/set API to read and write arbitrary data types at arbitrary byte offsets. This DataView object can be preset to use little or big endian format. Sice you don't know in wich endianness you recive raw data from the web, a rule of thumb is: upon receiving binary data from the web server, make one pass over it with a DataView.
			There is one special typed array view, Uint8ClampedArray, which clamps (clamping values mean values below the min become min, values above the maximum become max) the values between 0 and 255 (used for canvas's ImageData).
			You can create multiple views (even different ones) onto the same data.
			To convert it back to a normal array you can use Array.from() (on the DataView) as well as the spread syntax ([...typedArray]).
			Because Typed Array is raw memory, the JS engine can pass the memory directly to native libraries without having to convert the data to a native representation. As a result, typed arrays perform a lot better than arrays for passing data to WebGL and other APIs dealing with binary data.
			To copy a typed array to another typed array, the fastest way is to use the typed array set method. (typedArray.set(anotherTypedArray)).
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Equality Comparisons
	There are four equality algorithms in JavaScript:
		IsLooselyEqual: implemented with	==. This will perform a type conversion when comparing two things. (extra: NaN != NaN, and -0 == +0)
		IsStrictlyEqual: implemented with	===. Same comparison as double equals (including for NaN, -0, and +0) but without type conversion.
		SameValue: implemented with			Object.is(). Determines whether two values are functionally identical in all contexts (no type conversion and no NaN == NaN, and -0 != +0).
		SameValueZero: can be implemented with custom code (not implemented in JS). It only differs from strict equality by treating NaN as equal, and only differs from same-value equality by treating -0 as equivalent to 0.
			function sameValueZero(x, y) {
				if (typeof x === "number" && typeof y === "number") {
					// x and y are equal (may be -0 and 0) or they are both NaN
					return x === y || (x !== x && y !== y);
				}
				return x === y;
			}
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Expressions and Operators
	All the normal ones in every lang.
	Worth mention:
		Comma operator: evaluates both of its operands and returns the value of the last operand. Primarily used inside a for loop (regarded bad style to use it elsewhere. Often two separate statements can and should be used instead).
		Unary operators: operation with only one operand. e.g. delete, typeof, void...
		Relational operators: compares its operands and returns a Boolean value based on whether the comparison is true.
			in: returns true if the specified property is in the specified object.
			instanceof: returns true if the specified object is of the specified object type.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Functions
	All the typcal syntax as most lang.
	Arrow functs: (params) => {...}
	Default params: function name (a, b = defaultValue) {...}. If not specified, undefined.
	Rest parameters: this syntax allows a function to accept an indefinite number of arguments as an array.
		function name (...theArgs) {...}. theArgs is an array.

	IIFE (Immediately Invoked Function Expression): function that runs as soon as it's defined. Enclose it in () and call it. (function () {...}) ();
		Contains two major parts:
			The anonymous function with lexical scope enclosed within the Grouping Operator "()". This prevents accessing variables within the IIFE idiom as well as polluting the global scope.
			The expression () through which the JS engine will directly interpret the function.
		Some use cases:
			Avoid polluting the global namespace: If some initiation code won't need to be use again, use the IIFE pattern. Cause an app could include many functions and global variables from different source files.
			Execute an async function: An async IIFE allows you to use await and for-await.
			The module pattern: create private and public variables and methods.
				e.g. const something = (param) => ((paramCopy) => { any var or method here is private })(param);
			For loop with var before ES6: before "let" and "const" this could be seen (old code) to replace the function scope variables.

	Arguments Object
		"arguments" is an array-like object accessible inside functions that contains the values of the arguments passed to that function.
			e.g. function name (a, b, c) {arguments[0] = a; arguments[1] = b; arguments[2] = c}
		local variable available within all non-arrow functions.
		a function of indefinite arity is a variadic function. The arguments object is useful for variadic functions.
		If a function has no rest, default, or destructured parameters, arguments[i] can be use to sync the new value of parameters.
		Functions that are passed rest, default or destructured parameters will not sync new values assigned to parameters in the body of the function with the arguments object. Instead, the arguments object in non-strict functions with complex parameters will always reflect the values passed to the function when the function was called.

	Scope and function stack
		Scope: A space or environment in which a particular variable or function can be accessed or used. The following scopes can be found in JS:
			Global scope: The default scope for all code running in script mode.
			Module scope: The scope for code running in module mode.
			Function scope: The scope created with a function.
			Block scope: The scope created with a pair of curly braces (a block).
		Variables declared with let or const belong to block scope.
		Function Stack (Call stack): The function stack is how the interpreter keeps track of its place in a script that calls multiple functions, like which function is currently executing and which functions within that function are being called.

	Recursion: recursion is when a function invokes itself.

	Closures
		Combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function.
		Lexical scoping
			Lexical environment for a function refers to the environment enclosing that function’s definition in the source code.
			The lexical environment is determined once and then fixed for the entire course of the program. This is why JS is called a statically-scoped language.
			Lexical scoping describes how a parser resolves variable names when functions are nested. This is how a function can use a local variable of a parent function even if not declared within itself.
		Functions in JavaScript form closures.
		Another definition: A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope AT THE TIME THE CLOSURE WAS CREATED. This allows the following example:
											function makeAdder(x) {
												return function (y) {
													return x + y;
												};
											}
											const add5 = makeAdder(5);
											console.log(add5(2));		// 7-> Works
			The instance of the anonym. function maintains a reference to its lexical environment, within which the variable x exists.
			If we were to make another function: const add10 = makeAdder(10); then the function is the same, but both have different lexical environments. In add5's lexical environment, x is 5, while in the lexical environment for add10, x is 10.
		You can use a closure anywhere that you might normally use an object with only a single method.
		Emulating private methods with closures:
			check example here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#emulating_private_methods_with_closures
			You can create a shared lexical environment for mutliple functions. Use an IIFE to have some private vars and methods and return the public functions you want to be used outside of that function. This way, those public functions (the ones you returned) have access to the private functions within the IIFE.
			Using closures in this way provides benefits that are normally associated with object-oriented programming. In particular, data hiding and encapsulation.
		Closure scope chain:
			Every closure has 3 scopes:
				Local scope (Own scope)
				Enclosing scope (can be block, function, or module scope)
				Global scope
			In the case where the outer function is itself a nested function, access to the outer function's scope includes the enclosing scope of the outer function, effectively creating a chain of function scopes.
		Each function instance manages its own scope and closure. Therefore, it is unwise to unnecessarily create functions within other functions if closures are not needed for a particular task, as it will negatively affect script performance.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Strict Mode
	A way to opt-in to a restricted variant of JavaScript, thereby implicitly opting out of “sloppy mode”.
	It isn’t just a subset: it intentionally has different semantics from regular code.
	Strict mode code and non-strict mode code can coexist so that scripts can opt into strict mode incrementally.
	Strict mode makes several changes to normal JS semantics:
		Eliminates some JavaScript silent errors by changing them to throw errors.
		Fixes mistakes that make it difficult for JavaScript engines to perform optimizations: strict mode code can sometimes run faster than identical code that’s not strict mode.
		Prohibits some syntax likely to be defined in future versions of ECMAScript.
	Strict mode applies to entire scripts or to individual functions. It doesn't apply to block statements enclosed in {} braces.

	Invoking strict mode:
		Strict mode for scripts: put "use strict"; before any other statements (top of the script).
		Strict mode for functions: put "use strict"; in the function's body before any other statements (top of the function).
			"use strict" can only be applied to functions with simple parameters. "use strict" in functions with rest, default or destructured parameters is a syntax error.
		Strict mode for modules: contents of JS modules are automatically in strict mode, with no statement needed to initiate it.
		Strict mode for classes: all parts of a class's body are strict mode code.

	Changes in strict mode
		changes converting mistakes into errors (as syntax errors or at runtime).
		changes simplifying how variable references are resolved.
		changes simplifying eval and arguments.
		changes making it easier to write "secure" JavaScript.
		changes anticipating future ECMAScript evolution.
		makes it impossible to accidentally create global variables. Assignments that would accidentally create global variables throw ReferenceError
		makes assignments which would silently fail (non-writable data, new property on a non-extensible object, etc) to throw an exception.
		attempts to delete a non-configurable or undeletable property throw TypeError. Also forbids deleting plain names (syntax error).
		requires that function parameter names be unique.
		forbids a 0-prefixed octal literal or octal escape sequence.
		forbids setting properties on primitive values (TypeError).
		Duplicate property names are considered a SyntaxError prior to ES2015. It no longer throws an error.
		simplifies how variable names map to particular variable definitions in the code (allowing some engine optimization).
		prohibits with.
-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- Extra
with keyword (is deprecated): The with statement extends the scope chain for a statement.
	Syntax: with (expresion) statement; // parentheses required
	There are two types of identifiers: qualified and unqualified. Unqualified identifier is one that does not indicate where it comes from. foo -> unquilified; foo.bar -> bar is qualified. Unqualified identifiers are resolved by searching the scope chain for a variable with that name. Qualified identifiers are resolved by searching the prototype chain of an object for a property with that name. The with statement adds the given object to the head of this scope chain during the evaluation of its statement body. Every unqualified name would first be searched within the object (through a in check) before searching in the upper scope chain.
-----------------------------------------------------------------------------------------------------------------------------------------------------
		eval does not introduce new variables into the surrounding scope (eval() function evaluates JavaScript code represented as a string and returns its completion value i.e. eval(script), where script is js code).
		block-scoped function declarations (divergent in sloppy mode) are explicitly specified in strict mode.
		eval and arguments can't be bound or assigned in language syntax.
		doesn't sync indices of the arguments object with each parameter binding (so arguments is like a copy of the params values at the moment the function was called, modifyng the params doesn't modify the arguments object).
		values passed as "this" to a function are not forced into being an object (if unspecified, "this" is undefined, not globalThis).
		it's no longer possible to "walk" the JavaScript stack.
		arguments.callee is no longer supported.
		it has some "Future-proofing JavaScript" with reserved words that aren't actually implemented yet (like interface, package, private, etc).

	Transitioning to strict mode
		You can migrate a codebase to strict mode by first adding "use strict" to a piece of source code, and then fixing all execution errors
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
The "this" keyword
	in methods: a method can use the "this" keyword To access the object which owns that method.
	alone: "this" refers to the global object.
	in functions: "this" refers to the global object.
	in functions in strict mode: "this" is undefined.
	in an event handler: "this" refers to the element that received the event.
	Methods like call(), apply(), and bind() can refer this to any object.

	Explicit binding: when you explicitly set the value of this in a function. For this, call(), apply() and bind() are used.
		call(): Pass in the required object as the first parameter during the function call. The actual parameters are passed after the object.
		apply(): Similar to call() but the arguments are passed as an array.
		bind(): creates a new function with a fixed this. These types of functions are commonly known as bound functions.

	Function Borrowing
		Function borrowing allows us to use the methods of one object on a different object without having to make a copy of that method and maintain it in two separate places.
		It is accomplished through the use of call(), apply() or bind(). e.g. you have a class Dog with the method bark(), and you create a class Cat. After an instance of Cat is made, the Cat object could bark() with the use of:
			call: dogObject.bark.call(catObject)
			apply: dogObject.bark.apply(catObject)
			bind: let catBark = dogObject.bark.bind(catObject); catBark();
		The central benefit is that it allows you to forego inheritance. There’s no reason to force a class to inherit from another if it's only to grant instances of the child class access to a single method. It also keeps you from having to write the same function twice and maintain it in two places.
		The most important practical application of function borrowing is for native methods, specifically, Array.prototype.slice. There are several list-like data structures that aren’t arrays, and it’s useful to be able to treat them as arrays and operate on them as such.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Asyncronous JS
	Asynchronous programming is a technique that lets your program start a task and still be able to be responsive to other events while that task runs, rather than having to wait until that task has finished.

	setTimeout(): runs a function once after the interval of time.
	setInterval(): runs a function repeatedly, starting after the interval of time, then repeating continuously at that interval.

	Event handlers
		a function that will be called, not right away, but whenever the event happens (a specific type of callback).
		event handlers are really a form of asynchronous programming.

	Callbacks
		a function that's passed into another function, with the expectation that it will be called at the appropriate time.
		callback-based code can get hard to understand when the callback itself has to call functions that accept a callback. Because we have to call callbacks inside callbacks, we get a deeply nested function, which is much harder to read and debug. This is sometimes called "callback hell" or the "pyramid of doom". For these reasons, most modern asynchronous APIs don't use callbacks. Instead, the foundation of asynchronous programming in JavaScript is the Promise.

	Promises
		an object returned by an asynchronous function, which represents the current state of the operation. The promise object provides methods to handle the eventual success or failure of the operation.
		another definition: an object that represents the success or failure of a given operation, usually an asynchronous operation.
		Promises are built upon the conventional try/catch model, and thus offers more convenience to developers in writing exception-handling code.
		a promise is created with a function (called: the executor), as argument. Whenever the function was successfully finished, the promise is resolved, if the function was interrupted, threw an error or didn't finish, the promise is rejected.
		Two arguments are passed to the executor:
			a function to be called when the async operation completes: resolve().
			a function to be called when the async operation fails: reject().
		as soon as a promise is created using new Promise() along with a function as argument, this function is executed immediately by the promise.
		States of a promise: since a promise "represents the current state of the operation", it has the following states:
			pending: hasn't finished yet.
			fulfilled: finished as a success.
			rejected: finished as a failure.
		when we call the Promise() constructor, it's set to "pending".
		every promise object has a [[PromiseState]].
		Value of a promise
			when an asynchronous operation completes it is ready with some sort of data to be utilised for further actions.
			a promise's value is set by passing an argument to the resolve() or the reject() function.
				if the operation succeeds, this is the "result" of the operation.
				if it fails, this is the "reason" for the failure.
		The then() method
			available to all promises via Promise.prototype, is used to execute a function when a promise is resolved or rejected.
			it accepts two arguments:
				a function to call once the promise is resolved: onFulfilled().
				a function to call once the promise is rejected: onRejected().
		The executor function
			it has a synchronous nature
			if Promise() is called without an executor, or if that executor is not a function, an exception is thrown.
		every promise object internally maintains two callback queues (which fill when the then() method is used)
			one holding all functions to fire on its resolution.
			one holding all functions to fire on its rejection.

	Chaining
		refers to the notion of subsequently calling then() on the promise returned by then(). Possible since then() returns a new promise.
		this return of a promise by then() is what enables subsequent calls to be made on its invocation expression; and thus chaining.
		if then() is called while its promise is still unsettled, the callbacks are queued internally, after that a new promise is created; its reference saved internally in another queue; and finally returned by the method. this returned promise is given the name derived promise.
		there are 3 options of a return for callbacks:
			Returning a non-promise value: fulfills the corresponding derived promise with that value.
			Throwing an exception: the returned promise is rejected with that reason. Consequently the derived promise is rejected that value.
			Returning a promise: the promise returned by then() abides by the result of this promise (if fulfilled, the derived promise fulfills. if rejected, the derived promise rejects, if still pending, the derived promise is put on pending state).

	Event Loop
		JS has a runtime model based on an event loop, which is responsible for executing the code, collecting and processing events, and executing queued sub-tasks.
		It got its name because of how it's usually implemented, which usually resembles:
												while (queue.waitForMessage()) {
													queue.processNextMessage();
												}
							(queue.waitForMessage() waits synchronously for a message to arrive )
		Runtime understanding (theoretical model, JS engines implement and heavily optimize this):
			Stack
				Function calls form a stack of frames.
				the arguments and local variables may continue to exist, as they are stored outside the stack, so they can be accessed by any nested functions long after their outer function has returned.
			Heap
				objects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.
			Queue (message queue)
				a list of messages to be processed. Each message has an associated function that gets called to handle the message.
				Each message is processed completely before any other message is processed.
				messages are added anytime an event occurs and there is an event listener attached to it.
			Zero delays
				Zero delay doesn't mean the call back will fire-off after zero milliseconds.
				The execution depends on the number of waiting tasks in the queue.
			Several runtimes communicating together
				a web worker or a cross-origin iframe has its own stack, heap, and message queue. Two distinct runtimes can only communicate through sending messages via the postMessage. This method adds a message to the other runtime if the latter listens to message events.
			Never blocking
				the event loop never blocks. Handling I/O is typically performed via events and callbacks, so when the app is waiting for an XHR request to return or an IndexedDB query to return, it can still process other things like user input.
			the event loop basically has one task: connecting the queue with the call stack if the call stack is empty.
		On NodeJS:
			is what allows Node.js to perform non-blocking I/O operations by offloading operations to the system kernel whenever possible.
			event loop's order of operations (each one of these op. are called "phase"):
											   ┌───────────────────────────┐
											┌─>│           timers          │
											│  └─────────────┬─────────────┘		┌──────────────────────────────┐
											│  ┌─────────────┴─────────────┐		│ Each phase has a FIFO queue  │
											│  │     pending callbacks     │		│ of callbacks to execute	   │
											│  └─────────────┬─────────────┘		└──────────────────────────────┘
											│  ┌─────────────┴─────────────┐
											│  │       idle, prepare       │
											│  └─────────────┬─────────────┘      ┌───────────────┐
											│  ┌─────────────┴─────────────┐      │   incoming:   │
											│  │           poll            │<─────┤  connections, │
											│  └─────────────┬─────────────┘      │   data, etc.  │
											│  ┌─────────────┴─────────────┐      └───────────────┘
											│  │           check           │		┌────────────────────────────────────────────┐
											│  └─────────────┬─────────────┘		│ any operation may schedule more operations │
											│  ┌─────────────┴─────────────┐		│ and new events processed in the poll phase │
											└──┤      close callbacks      │		│ are queued by the kernel					 │
											   └───────────────────────────┘		└────────────────────────────────────────────┘
				timers: executes callbacks scheduled by setTimeout() and setInterval().
					A timer specifies the threshold after which a provided callback may be executed.
					will run as early as they can be scheduled after the specified time has passed, however, OS scheduling or the running of other callbacks may delay them.
					Technically, the poll phase controls when timers are executed. When the event loop enters the poll phase it will wait (if queue is empty) for the number of ms remaining until the soonest timer's threshold is reached.
				pending callbacks: executes I/O callbacks deferred to the next loop iteration.
					This phase executes callbacks for some system operations. e.g. some OS want to wait to report errors, this will be queued to execute in the pending callbacks phase.
				idle, prepare: only used internally.
				poll: retrieve new I/O events; execute I/O related callbacks (almost all); node will block here when appropriate.
					The poll phase has two main functions:
						1 Calculating how long it should block and poll for I/O.
						2 Processing events in the poll queue.
					When the event loop enters the poll phase:
						If the poll queue is not empty, the event loop will iterate through its queue of callbacks executing them synchronously.
						If the poll queue is empty but no timer is scheduled:
							If scripts have been scheduled by setImmediate(), it'll end the poll and continue to the check phase.
							If scripts haven't been scheduled by setImmediate(), it'll wait for callbacks to be added to the queue and execute them.
						If the poll queue is empty and a timer is scheduled:
							it'll wrap back to the timers phase to execute those timers' callbacks.
				check: setImmediate() callbacks are invoked here.
					This phase allows a person to execute callbacks immediately after the poll phase has completed.
				close callbacks: some close callbacks.
					If a socket or handle is closed abruptly, the 'close' event will be emitted in this phase.
-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- Extra
https://softwareengineering.stackexchange.com/questions/294346/c-runtime-and-runtime-linking -> nice runtimes explanation

Nodejs documentation:

setTimeout() vs setImmediate()
	setImmediate() is designed to execute a script once the current poll phase completes.
	setTimeout() schedules a script to be run after a minimum threshold in ms has elapsed.
The main advantage to using setImmediate() over setTimeout() is setImmediate() will always be executed before any timers if scheduled within an I/O cycle, independently of how many timers are present.

Understanding process.nextTick()
	process.nextTick() is not technically part of the event loop. Regardless of the current phase of the event loop, the nextTickQueue will be processed after the current operation (defined as: a transition from the C/C++ handler, and handling the JS that needs to be executed) is completed.
	any time you call process.nextTick() in a phase, all callbacks passed to this function will be resolved before the event loop continues.

process.nextTick() vs setImmediate()
	process.nextTick() fires immediately on the same phase
	setImmediate() fires on the following iteration or 'tick' of the event loop
	We recommend developers use setImmediate() in all cases because it's easier to reason about.
	Why use process.nextTick()?
		Allow users to handle errors, cleanup any then unneeded resources, or perhaps try the request again before the event loop continues.
		At times it's necessary to allow a callback to run after the call stack has unwound but before the event loop continues.
-----------------------------------------------------------------------------------------------------------------------------------------------------
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Working with API's
	API's are constructs made available in programming languages to allow developers to create complex functionality more easily. They abstract more complex code away from you, providing some easier syntax to use in its place.
-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- Extra
Library vs API
	A library is a collection of functionality not making up an application of its own, but offered to application software to ease implementing some tasks.
	The way of interacting with that library is defined by some API.
	So there can be multiple version of a library (or implementation, from different vendors) with one same API to interact with them.

Framework vs Library
	The key difference between a library and a framework is "Inversion of Control".
		When calling a method from a library, the developer is in control.
		With a framework, the control is inverted: the framework calls the developer's code.
-----------------------------------------------------------------------------------------------------------------------------------------------------

	JS API's
		client side js has many api's but generally fall into two categories:
			Browser APIs: built into your web browser.
			Third-party APIs: not built into the browser by default, and you have to retrieve their code (or information) from somewhere on the Web.

	How do APIs work?
		Generally api's have common features and similar themes to how they work:
			They are based on objects
				Your code interacts with APIs using JS objects, which serve as containers for the data (properties), and the functionality (methods) it makes available.
			They have recognizable entry points
				When using an API, you should make sure you know where the entry point is for the API.
			They often use events to handle changes in state
			They have additional security mechanisms where appropriate (e.g. some of the modern WebAPIs will only work on pages served over HTTPS).

	Fetching data from the server
		The main API here is the Fetch API. This enables JavaScript running in a page to make an HTTP request to a server to retrieve specific resources.
		In the early days, this general technique was known as Asynchronous JavaScript and XML (Ajax), because it tended to request XML data.

	XMLHttpRequest (XHR)
		objects used to interact with servers.
		used heavily in AJAX programming.
		can be used to retrieve any type of data (not just XML), with protocols other than HTTP.
		If the communication needs to involve receiving event data or message data, use server-sent events through the EventSource interface.
		For full-duplex communication, WebSockets may be a better choice.

	The Fetch API
		considered a modern replacement for XMLHttpRequest.
		it's a simpler API and has more features than XMLHttpRequest.
		uses Request and Response objects.
		the entry point to the Fetch API is a global function called fetch().
		fetch() takes one mandatory argument, the path to the resource you want to fetch.
		fetch() returns a promise (since it's an async api), that resolves to a Response object.
		the response can be formatted into many different object, this are just examples:
			.text(): plain text.
			.json(): a json object.
			.blob(): a blob (Blob is an abbreviation of "Binary Large Object" and can basically be used to represent large file-like objects).
		You can create a request and response directly using the Request() and Response() constructors, but it's uncommon. These are more likely to be created as results of other API actions.
-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- Extra
Web Workers API
	Web Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application.
	A worker is an object that runs a named JS file, that contains the code that will run in the worker thread.
	you can run almost any code you like inside a worker thread. Some exceptions:
		you can't directly manipulate the DOM from inside a worker.
		you can't use some default methods and properties of the window object.
	Data is sent between workers and the main thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler.
	There are a number of different types of workers:
		Dedicated workers: are utilized by a single script. This context is represented by a DedicatedWorkerGlobalScope object.
		Shared workers: can be utilized by multiple scripts running in different windows, IFrames, etc..., as long as they are in the same domain as the worker. These scripts must communicate via an active port.
		Service Workers: essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests and take appropriate action based on whether the network is available, and update assets residing on the server. They also allow access to push notifications and background sync APIs.
	methods are defined in WindowOrWorkerGlobalScope, and made available to workers through their own WorkerGlobalScope-derived contexts:
		DedicatedWorkerGlobalScope for dedicated workers
		SharedWorkerGlobalScope for shared workers
		ServiceWorkerGlobalScope for service workers
-----------------------------------------------------------------------------------------------------------------------------------------------------
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Classes
	

*****************************************************************************************************************************************************








