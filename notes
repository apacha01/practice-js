https://roadmap.sh/javascript


*****************************************************************************************************************************************************
Primitives:
	All the normal (bigint, boolean, etc...)
	undefined: default value for variables declared.
	Symbol: built-in object whose constructor returns a symbol that's guaranteed to be unique (often used to add unique property keys to an object that won't collide with keys any other code might add to the object). Every Symbol() call is guaranteed to return a unique Symbol. Every Symbol.for("key") call will always return the same Symbol for a given value of "key". Symbols are garbage collectable. To create Symbols available across files and even across realms (each of which has its own global scope), use the methods Symbol.for() and Symbol.keyFor() to set and retrieve Symbols from the global Symbol registry.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Objects

Generalities
	Objects are used to store keyed collections of various data and complex entities.
	Can be created with "{ ... }" (literal) or "new Object()" (constructor) with an optional list of properties (“key: value” pair) comma separated.
	Property values are accessible using the dot notation: object.property
	To remove a property, use the delete operator: delete object.property;
	Multiword property names are posible, but must be quoted. For this, the dot access doesn’t work: object.multiword property -> error. So use object["multiword property"]
	Square brackets also provide a way to obtain the property name as the result of any expression: let key = "likes birds"; user[key] = true; The dot notation cannot be used in a similar way: let key = "name"; console.log(user.key) -> undefined

Computed properties
	When you use square brackets in an object literal, when creating an object:
		let fruit = "apple";
		let bag = { [fruit]: 5, };
		bag.apple -> 5
	Computed properties means that, if [fruit] is used, the property name should be taken from fruit.
	Essentially, that works the same as:
		let fruit = "apple";
		let bag = {};
		bag[fruit] = 5;

Property value shorthand
	The use-case of making a property from a variable is so common, that there’s a special "property value shorthand" to make it shorter.
	Instead of {name: name, age: age,} -> {name, age}

Property names limitations
	A variable cannot have a name equal to one of the language-reserved words, but for an object property, there’s no such restriction.
	Other types are automatically converted to strings. (so you can write 0: "..." instead of "0":"...").
	There’s a minor gotcha with a special property named __proto__. We can’t set it to a non-object value. (See "Object prototypes" below)

Property existence test, “in” operator
	It’s possible to access any property. There's no error if the property doesn’t exist it just returns undefined.
	So there’s a special operator "in" for checking if a property exists. The syntax is: "key" in object (if quotes ommited, the var should contain the actual name to be tested)
	On the left side of in there must be a property name, on the right is the object.

The "for in" loop
	To walk over all keys of an object, there exists a special form of the loop: for in. Syntax is: for key in object {...}
	Example:
		for (let key in user) {
			key			-> name, age, etc
			user[key]	-> "Jhon Doe", 35, etc
		}

Ordered like an object
	Are objects ordered? The short answer is: “ordered in a special fashion”: integer properties (a string that can be converted to-and-from an integer without a change) are sorted, others appear in creation order.
	If the keys are non-integer, then they are listed in the creation order.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Object prototypes
	Prototypes are the mechanism by which JavaScript objects inherit features from one another.

The prototype chain
	Every object in JavaScript has a built-in property, which is called [[Prototype]]. But this property is hidden, so you can only access it with certain words / methods (see "Setting a prototype" below). The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has null for its own prototype.
	When accessing a property of an object: if the property can't be found in the object itself, the prototype is searched for the property. If it still can't be found, then the prototype's prototype is searched, and so on until the property is found or the end of the chain is reached (undefined is returned).
	Object.prototype is the most basic prototype, that all objects have by default. The prototype of Object.prototype is null (end of the chain).
	It's possible to mutate any member of the chain or even swap out the prototype at runtime, so concepts like static dispatching (extra below) don't exist in JavaScript.

------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------- Extra
static dispatch is a form of polymorphism fully resolved during compile time. It is a form of method dispatch, which describes how a language or environment will select which implementation of a method or function to use.
------------------------------------------------------------------------------------------------------------------------------------------------

Shadowing properties
	This is when you define a property in an object, when a property with the same name is defined in the object's prototype.
	Example: (Object.prototype has the toString() method)
			let obj = {name: "Jhon", greet {console.log("hello")} } -> obj.toString() = [object Object]
			obj.toString = () => "Name:" + obj.name; -> obj.toString() = Name: Jhon

Setting a prototype
	There are a lot of ways to do it: Object.create() and constructors.
		Using syntax constructs you can directly set the property __proto__ to a value (supported in all modern engines).
			const p = { b: 2, __proto__: o };
		When you call a function as a constructor, this property is set as the prototype of the newly constructed object.
			const personPrototype = {greet() {console.log("hello my name is", this.name);}};
			function Person (name) {this.name = name;}
		Object.create() creates a new object and lets you specify an object that will be the new object's prototype.
			const personPrototype = {greet() {console.log("hello");}};
			const carl = Object.create(personPrototype);
			carl.greet() -> hello
			Object.assign(Person.prototype, personPrototype) or Person.prototype.greet = personPrototype.greet
			Now every time a Person object is created (new Person("name")) it will have the .greet() method (__proto__ should not be confused with the func.prototype property of functions, which instead specifies the [[Prototype]] to be assigned to all instances of objects created by the given function when used as a constructor).
		With classes, since the actual implementation of classes inheritance is with this prototype model:
			class Square { constructor(size) {this.size = size;}}
			class FilledSquare { constructor(size, color) {this.size = size; this.color = color;}}
			const fs = new FilledSquare(5, "blue"); -> fs ---> FilledSquare.prototype ---> Square.prototype ---> Object.prototype ---> null
		With Object.setPrototypeOf() you can mutate the [[Prototype]] internal property of an existing object.
			const obj = { a: 1 };
			const anotherObj = { b: 2 };
			Object.setPrototypeOf(obj, anotherObj);
		All objects inherit the Object.prototype.__proto__ setter, which can be used to set the [[Prototype]] of an existing object (deprecated, you should almost always use Object.setPrototypeOf instead.)
			obj.__proto__ = somePrototype;
	It's common to see this pattern, in which methods are defined on the prototype, but data properties are defined in the constructor.
	Properties that are defined directly in the object, are called "own properties", and you can check whether a property is an own property using Object.hasOwn():
		const irma = new Person("Irma");
		console.log(Object.hasOwn(irma, "name")); -> true
		console.log(Object.hasOwn(irma, "greet")); -> false
	Properties that are defined in the prototype of the object are inherited.

Prototypes and inheritance
	Prototypes support a version of inheritance. If two objects have another one prototypes, then they can inherit the common properties, while adding and redefining those properties which need to differ (see Prototypal Inheritance below).
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Prototypal Inheritance
	With the prototypical inheritance model is fairly trivial to build a classic model on top of a prototypical model. That's actually how classes are implemented.
	Classes are now widely adopted, but they do not bring a new inheritance pattern, they just abstract most of the prototypical mechanism away.

Inheritance with the prototype chain
	Inheriting properties
		In an object literal like { a: 1, b: 2, __proto__: c }, the value c (has to be null or an object) will become the [[Prototype]] of the object, while the other keys (a & b) will become the own properties of the object.
		Setting a property to an object creates an own property.
	Inheriting methods
		JS doesn't have "methods" like class-based languages define them. In JS, any function can be added to an object in the form of a property.
		An inherited function acts just as any other property.
		When an inherited function is executed, the value of "this" points to the inheriting object, not the prototype object where the function is an own property.

Constructors
	Constructors are functions called with new.
	Use a constructor function to automatically set the [[Prototype]] for every object manufactured.
		function Box(value) {this.value = value;}
		Box.prototype.getValue = function () {return this.value;};
		const b = new Box(1)
		Now every instance created with new Box(value) will have the getValue method. But because this references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating Box.prototype (even the ones that are already instanciated. e.g. changing Box.prototype.getValue will alter the getValue function on b even if b is untouched).
	Constructor.prototype by default has one own property: constructor, which references the constructor function itself, meaning Box.prototype.constructor === Box. This allows one to access the original constructor from any instance.
	When you create a class, the methods are created on Class.prototype directly (Classes are syntax sugar over constructor functions)
		class Box {
			constructor(value) {this.value = value;}

			// Methods are created on Box.prototype
			getValue() {return this.value;}
		}
	A corollary is (re-assigning Constructor.prototype) a bad idea for two reasons:
		The [[Prototype]] of instances created before the reassignment are now referencing a different object from the [[Prototype]] of instances created after the reassignment.
		Unless you manually re-set the constructor property, the constructor function can no longer be traced from instance.constructor, which may break user expectation.

Implicit constructors of literals
	Since this: let a = [1, 2, 3] is = to this: let a = new Array(1, 2, 3), one can expect that some literals have a default prototype (in this case Array.prototype [which has the indexOf() function for example]).
------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------- Extra
There is one misfeature that is extending Object.prototype or one of the other built-in prototypes. An example of this misfeature is, defining Array.prototype.myMethod = function () {...} and then using myMethod on all array instances. This misfeature is called monkey patching. This risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break.
------------------------------------------------------------------------------------------------------------------------------------------------

Building longer inheritance chains
	By default, Constructor.prototype is a plain object and the Object.prototype [[Prototype]] is null, i.e. Constructor.prototype -> Object.protorype -> null
	To build longer prototype chains, we can set the [[Prototype]] of Constructor.prototype via the Object.setPrototypeOf() function. In class terms, this is equivalent to using the extends syntax.
		function Something () {}
		function SomethingElse () {}
		Object.setPrototypeOf(Something. SomethingElse) => Something.prototype -> SomethingElse.prototype -> Constructor.prototype -> Object.protorype -> null

Inspecting prototypes: a deeper dive
	All functions have a special property named prototype, except arrow functions.
	It's possible to add properties to the prototype of a function.
	Now you can use the new operator to create an instance of the function based on the prototype.
	Calling a function with the new operator returns an object that is an instance of the function. Properties can then be added onto this object.

Performance
	Trying to access nonexistent properties will always traverse the full prototype chain.
	When iterating over the properties of an object, EVERY property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, use hasOwnProperty or Object.hasOwn methods. It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Type Casting
	Type conversion
		Transfer of data from one data type to another.

	Type coercion
		Automatic or implicit conversion of values from one data type to another.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Data Structures
	Keyed Collections: collections of data which are indexed by a key.
		Maps
			Simple key/value object and iteratetable in insertion order.
			You can use a for...of loop to return an array of [key, value] for each iteration.
			Traditionally, objects have been used to map strings to values. Map objects, however, have a few more advantages:
				The keys of an Object are Strings or Symbols, where they can be of any value for a Map.
				You can get the size of a Map easily, while you have to manually keep track of size for an Object.
				The iteration of maps is in insertion order of the elements.
				An Object has a prototype, so there are default keys in the map. (This can be bypassed using map = Object.create(null).)
		WeakMaps
			Collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any type, and which does not create strong references to its keys. i.e. an object's presence as a key in a WeakMap does not prevent the object from being garbage collected.
			Once an object used as key has been collected, its value in any WeakMap becomes candidate for garbage collection as well.
			A WeakMap doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a WeakMap.
		Sets
			Collections of unique values of any type.
			You can iterate its elements in insertion order.
			Converting between Array and Set: use Array.from or the spread syntax to go from Set to Array, or the Set to go from Array to Set.
		WeakSets
			Collections of garbage-collectable values, including only objects and non-registered symbols.
			If there is no other reference to an object stored in the WeakSet, they can be garbage collected.
			WeakSets are not enumerable.
		Both the key equality of Maps and the value equality of Sets are based on the SameValueZero algorithm (see Equality Comparisons below).

	Indexed Collections: collections of data which are ordered by an index value.
		Arrays (omiting usual info common to every prog. lang.)
			You can create an array in 3 ways:
				new Array(1,2...)
				Array(1,2...)
				[1,2...]			(this syntax is called "array literal" or "array initializer")
			This creates an array with only one element, the number 42: const arr = [42];
			This creates an empty array with length 42: const arr = []; arr.length = 42;
			Writing a value that is shorter than the number of stored items truncates the array. Writing 0 empties it entirely.
			The forEach() method provides a way of iterating over an array: arr.forEach(...)
			Arrays can contain "empty slots" (this are called "sparse arrays"), which are not the same as slots filled with the value undefined.
			Arrays can also be used like objects, to store related information: const arr = [1, 2, 3]; arr.property = "value";
			Some objects look and behave like arrays on the surface but do not share all of their methods. This are array-like objects.
			Array methods cannot be called directly on array-like objects. But you can call them indirectly using Function.prototype.call().
				Array.prototype.forEach.call(yourArrayLikeObject, (item) => { ... })
			Array prototype methods can be used on strings as well, since they provide sequential access to their characters.
		Typed Arrays(similar to arrays in many ways)
			Array-like objects that provide a mechanism for reading and writing raw binary data in memory buffers.
			Each entry in a typed array is a raw binary value in one of the supported formats, from 8-bit integers to 64-bit floating-point numbers.
			Calling Array.isArray() on a typed array returns false.
			To achieve maximum flexibility and efficiency, JavaScript typed arrays split the implementation into buffers and views.
				A buffer (ArrayBuffer object) is an object representing a chunk of data; it has no format to speak of, and offers no mechanism for accessing its contents. To access it, you need to use a view. ArrayBuffer is a fixed-length binary data buffer.
				A view provides a context, i.e data type; starting offset; number of elements, that turns the data into an actual typed array. This object access the buffer allowing you to read/write in it.
			There are two types of views:
				Views that act like single-type arrays to a segment of an ArrayBuffer. This ones have self-descriptive names and provide views for all the usual numeric types (like Uint8Array, Float32Array, etc). This typed arrays use the endianness of the CPU.
				The DataView object that it is meant for handling heterogeneous data. the DataView object provides you a get/set API to read and write arbitrary data types at arbitrary byte offsets. This DataView object can be preset to use little or big endian format. Sice you don't know in wich endianness you recive raw data from the web, a rule of thumb is: upon receiving binary data from the web server, make one pass over it with a DataView.
			There is one special typed array view, Uint8ClampedArray, which clamps (clamping values mean values below the min become min, values above the maximum become max) the values between 0 and 255 (used for canvas's ImageData).
			You can create multiple views (even different ones) onto the same data.
			To convert it back to a normal array you can use Array.from() (on the DataView) as well as the spread syntax ([...typedArray]).
			Because Typed Array is raw memory, the JS engine can pass the memory directly to native libraries without having to convert the data to a native representation. As a result, typed arrays perform a lot better than arrays for passing data to WebGL and other APIs dealing with binary data.
			To copy a typed array to another typed array, the fastest way is to use the typed array set method. (typedArray.set(anotherTypedArray)).
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Equality Comparisons
	




*****************************************************************************************************************************************************













