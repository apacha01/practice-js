https://roadmap.sh/javascript


*****************************************************************************************************************************************************
Primitives:
	All the normal (bigint, boolean, etc...)
	undefined: default value for variables declared.
	Symbol: built-in object whose constructor returns a symbol that's guaranteed to be unique (often used to add unique property keys to an object that won't collide with keys any other code might add to the object). Every Symbol() call is guaranteed to return a unique Symbol. Every Symbol.for("key") call will always return the same Symbol for a given value of "key". Symbols are garbage collectable. To create Symbols available across files and even across realms (each of which has its own global scope), use the methods Symbol.for() and Symbol.keyFor() to set and retrieve Symbols from the global Symbol registry.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Objects

Generalities
	Objects are used to store keyed collections of various data and complex entities.
	Can be created with "{ ... }" (literal) or "new Object()" (constructor) with an optional list of properties (“key: value” pair) comma separated.
	Property values are accessible using the dot notation: object.property
	To remove a property, use the delete operator: delete object.property;
	Multiword property names are posible, but must be quoted. For this, the dot access doesn’t work: object.multiword property -> error. So use object["multiword property"]
	Square brackets also provide a way to obtain the property name as the result of any expression: let key = "likes birds"; user[key] = true; The dot notation cannot be used in a similar way: let key = "name"; console.log(user.key) -> undefined

Computed properties
	When you use square brackets in an object literal, when creating an object:
		let fruit = "apple";
		let bag = { [fruit]: 5, };
		bag.apple -> 5
	Computed properties means that, if [fruit] is used, the property name should be taken from fruit.
	Essentially, that works the same as:
		let fruit = "apple";
		let bag = {};
		bag[fruit] = 5;

Property value shorthand
	The use-case of making a property from a variable is so common, that there’s a special "property value shorthand" to make it shorter.
	Instead of {name: name, age: age,} -> {name, age}

Property names limitations
	A variable cannot have a name equal to one of the language-reserved words, but for an object property, there’s no such restriction.
	Other types are automatically converted to strings. (so you can write 0: "..." instead of "0":"...").
	There’s a minor gotcha with a special property named __proto__. We can’t set it to a non-object value. (See "Object prototypes" below)

Property existence test, “in” operator
	It’s possible to access any property. There's no error if the property doesn’t exist it just returns undefined.
	So there’s a special operator "in" for checking if a property exists. The syntax is: "key" in object (if quotes ommited, the var should contain the actual name to be tested)
	On the left side of in there must be a property name, on the right is the object.

The "for in" loop
	To walk over all keys of an object, there exists a special form of the loop: for in. Syntax is: for key in object {...}
	Example:
		for (let key in user) {
			key			-> name, age, etc
			user[key]	-> "Jhon Doe", 35, etc
		}

Ordered like an object
	Are objects ordered? The short answer is: “ordered in a special fashion”: integer properties (a string that can be converted to-and-from an integer without a change) are sorted, others appear in creation order.
	If the keys are non-integer, then they are listed in the creation order.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Object prototypes
	Prototypes are the mechanism by which JavaScript objects inherit features from one another.

The prototype chain
	Every object in JavaScript has a built-in property, which is called [[Prototype]]. But this property is hidden, so you can only access it with certain words / methods (see "Setting a prototype" below). The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has null for its own prototype.
	When accessing a property of an object: if the property can't be found in the object itself, the prototype is searched for the property. If it still can't be found, then the prototype's prototype is searched, and so on until the property is found or the end of the chain is reached (undefined is returned).
	Object.prototype is the most basic prototype, that all objects have by default. The prototype of Object.prototype is null (end of the chain).
	It's possible to mutate any member of the chain or even swap out the prototype at runtime, so concepts like static dispatching (extra below) don't exist in JavaScript.

------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------- Extra
static dispatch is a form of polymorphism fully resolved during compile time. It is a form of method dispatch, which describes how a language or environment will select which implementation of a method or function to use.
------------------------------------------------------------------------------------------------------------------------------------------------

Shadowing properties
	This is when you define a property in an object, when a property with the same name is defined in the object's prototype.
	Example: (Object.prototype has the toString() method)
			let obj = {name: "Jhon", greet {console.log("hello")} } -> obj.toString() = [object Object]
			obj.toString = () => "Name:" + obj.name; -> obj.toString() = Name: Jhon

Setting a prototype
	There are a lot of ways to do it: Object.create() and constructors.
		Using syntax constructs you can directly set the property __proto__ to a value (supported in all modern engines).
			const p = { b: 2, __proto__: o };
		When you call a function as a constructor, this property is set as the prototype of the newly constructed object.
			const personPrototype = {greet() {console.log("hello my name is", this.name);}};
			function Person (name) {this.name = name;}
		Object.create() creates a new object and lets you specify an object that will be the new object's prototype.
			const personPrototype = {greet() {console.log("hello");}};
			const carl = Object.create(personPrototype);
			carl.greet() -> hello
			Object.assign(Person.prototype, personPrototype) or Person.prototype.greet = personPrototype.greet
			Now every time a Person object is created (new Person("name")) it will have the .greet() method (__proto__ should not be confused with the func.prototype property of functions, which instead specifies the [[Prototype]] to be assigned to all instances of objects created by the given function when used as a constructor).
		With classes, since the actual implementation of classes inheritance is with this prototype model:
			class Square { constructor(size) {this.size = size;}}
			class FilledSquare { constructor(size, color) {this.size = size; this.color = color;}}
			const fs = new FilledSquare(5, "blue"); -> fs ---> FilledSquare.prototype ---> Square.prototype ---> Object.prototype ---> null
		With Object.setPrototypeOf() you can mutate the [[Prototype]] internal property of an existing object.
			const obj = { a: 1 };
			const anotherObj = { b: 2 };
			Object.setPrototypeOf(obj, anotherObj);
		All objects inherit the Object.prototype.__proto__ setter, which can be used to set the [[Prototype]] of an existing object (deprecated, you should almost always use Object.setPrototypeOf instead.)
			obj.__proto__ = somePrototype;
	It's common to see this pattern, in which methods are defined on the prototype, but data properties are defined in the constructor.
	Properties that are defined directly in the object, are called "own properties", and you can check whether a property is an own property using Object.hasOwn():
		const irma = new Person("Irma");
		console.log(Object.hasOwn(irma, "name")); -> true
		console.log(Object.hasOwn(irma, "greet")); -> false
	Properties that are defined in the prototype of the object are inherited.

Prototypes and inheritance
	Prototypes support a version of inheritance. If two objects have another one prototypes, then they can inherit the common properties, while adding and redefining those properties which need to differ (see Prototypal Inheritance below).
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Prototypal Inheritance
	With the prototypical inheritance model is fairly trivial to build a classic model on top of a prototypical model. That's actually how classes are implemented.
	Classes are now widely adopted, but they do not bring a new inheritance pattern, they just abstract most of the prototypical mechanism away.

Inheritance with the prototype chain
	Inheriting properties
		In an object literal like { a: 1, b: 2, __proto__: c }, the value c (has to be null or an object) will become the [[Prototype]] of the object, while the other keys (a & b) will become the own properties of the object.
		Setting a property to an object creates an own property.
	Inheriting methods
		JS doesn't have "methods" like class-based languages define them. In JS, any function can be added to an object in the form of a property.
		An inherited function acts just as any other property.
		When an inherited function is executed, the value of "this" points to the inheriting object, not the prototype object where the function is an own property.

Constructors
	Constructors are functions called with new.
	Use a constructor function to automatically set the [[Prototype]] for every object manufactured.
		function Box(value) {this.value = value;}
		Box.prototype.getValue = function () {return this.value;};
		const b = new Box(1)
		Now every instance created with new Box(value) will have the getValue method. But because this references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating Box.prototype (even the ones that are already instanciated. e.g. changing Box.prototype.getValue will alter the getValue function on b even if b is untouched).
	Constructor.prototype by default has one own property: constructor, which references the constructor function itself, meaning Box.prototype.constructor === Box. This allows one to access the original constructor from any instance.
	When you create a class, the methods are created on Class.prototype directly (Classes are syntax sugar over constructor functions)
		class Box {
			constructor(value) {this.value = value;}

			// Methods are created on Box.prototype
			getValue() {return this.value;}
		}
	A corollary is (re-assigning Constructor.prototype) a bad idea for two reasons:
		The [[Prototype]] of instances created before the reassignment are now referencing a different object from the [[Prototype]] of instances created after the reassignment.
		Unless you manually re-set the constructor property, the constructor function can no longer be traced from instance.constructor, which may break user expectation.

Implicit constructors of literals
	Since this: let a = [1, 2, 3] is = to this: let a = new Array(1, 2, 3), one can expect that some literals have a default prototype (in this case Array.prototype [which has the indexOf() function for example]).
------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------- Extra
There is one misfeature that is extending Object.prototype or one of the other built-in prototypes. An example of this misfeature is, defining Array.prototype.myMethod = function () {...} and then using myMethod on all array instances. This misfeature is called monkey patching. This risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break.
------------------------------------------------------------------------------------------------------------------------------------------------

Building longer inheritance chains
	By default, Constructor.prototype is a plain object and the Object.prototype [[Prototype]] is null, i.e. Constructor.prototype -> Object.protorype -> null
	To build longer prototype chains, we can set the [[Prototype]] of Constructor.prototype via the Object.setPrototypeOf() function. In class terms, this is equivalent to using the extends syntax.
		function Something () {}
		function SomethingElse () {}
		Object.setPrototypeOf(Something. SomethingElse) => Something.prototype -> SomethingElse.prototype -> Constructor.prototype -> Object.protorype -> null

Inspecting prototypes: a deeper dive
	All functions have a special property named prototype, except arrow functions.
	It's possible to add properties to the prototype of a function.
	Now you can use the new operator to create an instance of the function based on the prototype.
	Calling a function with the new operator returns an object that is an instance of the function. Properties can then be added onto this object.

Performance
	Trying to access nonexistent properties will always traverse the full prototype chain.
	When iterating over the properties of an object, EVERY property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, use hasOwnProperty or Object.hasOwn methods. It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Type Casting
	Type conversion
		Transfer of data from one data type to another.

	Type coercion
		Automatic or implicit conversion of values from one data type to another.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Data Structures
	Keyed Collections: collections of data which are indexed by a key.
		Maps
			Simple key/value object and iteratetable in insertion order.
			You can use a for...of loop to return an array of [key, value] for each iteration.
			Traditionally, objects have been used to map strings to values. Map objects, however, have a few more advantages:
				The keys of an Object are Strings or Symbols, where they can be of any value for a Map.
				You can get the size of a Map easily, while you have to manually keep track of size for an Object.
				The iteration of maps is in insertion order of the elements.
				An Object has a prototype, so there are default keys in the map. (This can be bypassed using map = Object.create(null).)
		WeakMaps
			Collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any type, and which does not create strong references to its keys. i.e. an object's presence as a key in a WeakMap does not prevent the object from being garbage collected.
			Once an object used as key has been collected, its value in any WeakMap becomes candidate for garbage collection as well.
			A WeakMap doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a WeakMap.
		Sets
			Collections of unique values of any type.
			You can iterate its elements in insertion order.
			Converting between Array and Set: use Array.from or the spread syntax to go from Set to Array, or the Set to go from Array to Set.
		WeakSets
			Collections of garbage-collectable values, including only objects and non-registered symbols.
			If there is no other reference to an object stored in the WeakSet, they can be garbage collected.
			WeakSets are not enumerable.
		Both the key equality of Maps and the value equality of Sets are based on the SameValueZero algorithm (see Equality Comparisons below).

	Indexed Collections: collections of data which are ordered by an index value.
		Arrays (omiting usual info common to every prog. lang.)
			You can create an array in 3 ways:
				new Array(1,2...)
				Array(1,2...)
				[1,2...]			(this syntax is called "array literal" or "array initializer")
			This creates an array with only one element, the number 42: const arr = [42];
			This creates an empty array with length 42: const arr = []; arr.length = 42;
			Writing a value that is shorter than the number of stored items truncates the array. Writing 0 empties it entirely.
			The forEach() method provides a way of iterating over an array: arr.forEach(...)
			Arrays can contain "empty slots" (this are called "sparse arrays"), which are not the same as slots filled with the value undefined.
			Arrays can also be used like objects, to store related information: const arr = [1, 2, 3]; arr.property = "value";
			Some objects look and behave like arrays on the surface but do not share all of their methods. This are array-like objects.
			Array methods cannot be called directly on array-like objects. But you can call them indirectly using Function.prototype.call().
				Array.prototype.forEach.call(yourArrayLikeObject, (item) => { ... })
			Array prototype methods can be used on strings as well, since they provide sequential access to their characters.
		Typed Arrays(similar to arrays in many ways)
			Array-like objects that provide a mechanism for reading and writing raw binary data in memory buffers.
			Each entry in a typed array is a raw binary value in one of the supported formats, from 8-bit integers to 64-bit floating-point numbers.
			Calling Array.isArray() on a typed array returns false.
			To achieve maximum flexibility and efficiency, JavaScript typed arrays split the implementation into buffers and views.
				A buffer (ArrayBuffer object) is an object representing a chunk of data; it has no format to speak of, and offers no mechanism for accessing its contents. To access it, you need to use a view. ArrayBuffer is a fixed-length binary data buffer.
				A view provides a context, i.e data type; starting offset; number of elements, that turns the data into an actual typed array. This object access the buffer allowing you to read/write in it.
			There are two types of views:
				Views that act like single-type arrays to a segment of an ArrayBuffer. This ones have self-descriptive names and provide views for all the usual numeric types (like Uint8Array, Float32Array, etc). This typed arrays use the endianness of the CPU.
				The DataView object that it is meant for handling heterogeneous data. the DataView object provides you a get/set API to read and write arbitrary data types at arbitrary byte offsets. This DataView object can be preset to use little or big endian format. Sice you don't know in wich endianness you recive raw data from the web, a rule of thumb is: upon receiving binary data from the web server, make one pass over it with a DataView.
			There is one special typed array view, Uint8ClampedArray, which clamps (clamping values mean values below the min become min, values above the maximum become max) the values between 0 and 255 (used for canvas's ImageData).
			You can create multiple views (even different ones) onto the same data.
			To convert it back to a normal array you can use Array.from() (on the DataView) as well as the spread syntax ([...typedArray]).
			Because Typed Array is raw memory, the JS engine can pass the memory directly to native libraries without having to convert the data to a native representation. As a result, typed arrays perform a lot better than arrays for passing data to WebGL and other APIs dealing with binary data.
			To copy a typed array to another typed array, the fastest way is to use the typed array set method. (typedArray.set(anotherTypedArray)).
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Equality Comparisons
	There are four equality algorithms in JavaScript:
		IsLooselyEqual: implemented with	==. This will perform a type conversion when comparing two things. (extra: NaN != NaN, and -0 == +0)
		IsStrictlyEqual: implemented with	===. Same comparison as double equals (including for NaN, -0, and +0) but without type conversion.
		SameValue: implemented with			Object.is(). Determines whether two values are functionally identical in all contexts (no type conversion and no NaN == NaN, and -0 != +0).
		SameValueZero: can be implemented with custom code (not implemented in JS). It only differs from strict equality by treating NaN as equal, and only differs from same-value equality by treating -0 as equivalent to 0.
			function sameValueZero(x, y) {
				if (typeof x === "number" && typeof y === "number") {
					// x and y are equal (may be -0 and 0) or they are both NaN
					return x === y || (x !== x && y !== y);
				}
				return x === y;
			}
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Expressions and Operators
	All the normal ones in every lang.
	Worth mention:
		Comma operator: evaluates both of its operands and returns the value of the last operand. Primarily used inside a for loop (regarded bad style to use it elsewhere. Often two separate statements can and should be used instead).
		Unary operators: operation with only one operand. e.g. delete, typeof, void...
		Relational operators: compares its operands and returns a Boolean value based on whether the comparison is true.
			in: returns true if the specified property is in the specified object.
			instanceof: returns true if the specified object is of the specified object type.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Functions
	All the typcal syntax as most lang.
	Arrow functs: (params) => {...}
	Default params: function name (a, b = defaultValue) {...}. If not specified, undefined.
	Rest parameters: this syntax allows a function to accept an indefinite number of arguments as an array.
		function name (...theArgs) {...}. theArgs is an array.

	IIFE (Immediately Invoked Function Expression): function that runs as soon as it's defined. Enclose it in () and call it. (function () {...}) ();
		Contains two major parts:
			The anonymous function with lexical scope enclosed within the Grouping Operator "()". This prevents accessing variables within the IIFE idiom as well as polluting the global scope.
			The expression () through which the JS engine will directly interpret the function.
		Some use cases:
			Avoid polluting the global namespace: If some initiation code won't need to be use again, use the IIFE pattern. Cause an app could include many functions and global variables from different source files.
			Execute an async function: An async IIFE allows you to use await and for-await.
			The module pattern: create private and public variables and methods.
				e.g. const something = (param) => ((paramCopy) => { any var or method here is private })(param);
			For loop with var before ES6: before "let" and "const" this could be seen (old code) to replace the function scope variables.

	Arguments Object
		"arguments" is an array-like object accessible inside functions that contains the values of the arguments passed to that function.
			e.g. function name (a, b, c) {arguments[0] = a; arguments[1] = b; arguments[2] = c}
		local variable available within all non-arrow functions.
		a function of indefinite arity is a variadic function. The arguments object is useful for variadic functions.
		If a function has no rest, default, or destructured parameters, arguments[i] can be use to sync the new value of parameters.
		Functions that are passed rest, default or destructured parameters will not sync new values assigned to parameters in the body of the function with the arguments object. Instead, the arguments object in non-strict functions with complex parameters will always reflect the values passed to the function when the function was called.

	Scope and function stack
		Scope: A space or environment in which a particular variable or function can be accessed or used. The following scopes can be found in JS:
			Global scope: The default scope for all code running in script mode.
			Module scope: The scope for code running in module mode.
			Function scope: The scope created with a function.
			Block scope: The scope created with a pair of curly braces (a block).
		Variables declared with let or const belong to block scope.
		Function Stack (Call stack): The function stack is how the interpreter keeps track of its place in a script that calls multiple functions, like which function is currently executing and which functions within that function are being called.

	Recursion: recursion is when a function invokes itself.

	Closures
		Combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function.
		Lexical scoping
			Lexical environment for a function refers to the environment enclosing that function’s definition in the source code.
			The lexical environment is determined once and then fixed for the entire course of the program. This is why JS is called a statically-scoped language.
			Lexical scoping describes how a parser resolves variable names when functions are nested. This is how a function can use a local variable of a parent function even if not declared within itself.
		Functions in JavaScript form closures.
		Another definition: A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope AT THE TIME THE CLOSURE WAS CREATED. This allows the following example:
											function makeAdder(x) {
												return function (y) {
													return x + y;
												};
											}
											const add5 = makeAdder(5);
											console.log(add5(2));		// 7-> Works
			The instance of the anonym. function maintains a reference to its lexical environment, within which the variable x exists.
			If we were to make another function: const add10 = makeAdder(10); then the function is the same, but both have different lexical environments. In add5's lexical environment, x is 5, while in the lexical environment for add10, x is 10.
		You can use a closure anywhere that you might normally use an object with only a single method.
		Emulating private methods with closures:
			check example here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#emulating_private_methods_with_closures
			You can create a shared lexical environment for mutliple functions. Use an IIFE to have some private vars and methods and return the public functions you want to be used outside of that function. This way, those public functions (the ones you returned) have access to the private functions within the IIFE.
			Using closures in this way provides benefits that are normally associated with object-oriented programming. In particular, data hiding and encapsulation.
		Closure scope chain:
			Every closure has 3 scopes:
				Local scope (Own scope)
				Enclosing scope (can be block, function, or module scope)
				Global scope
			In the case where the outer function is itself a nested function, access to the outer function's scope includes the enclosing scope of the outer function, effectively creating a chain of function scopes.
		Each function instance manages its own scope and closure. Therefore, it is unwise to unnecessarily create functions within other functions if closures are not needed for a particular task, as it will negatively affect script performance.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Strict Mode
	A way to opt-in to a restricted variant of JavaScript, thereby implicitly opting out of “sloppy mode”.
	It isn’t just a subset: it intentionally has different semantics from regular code.
	Strict mode code and non-strict mode code can coexist so that scripts can opt into strict mode incrementally.
	Strict mode makes several changes to normal JS semantics:
		Eliminates some JavaScript silent errors by changing them to throw errors.
		Fixes mistakes that make it difficult for JavaScript engines to perform optimizations: strict mode code can sometimes run faster than identical code that’s not strict mode.
		Prohibits some syntax likely to be defined in future versions of ECMAScript.
	Strict mode applies to entire scripts or to individual functions. It doesn't apply to block statements enclosed in {} braces.

	Invoking strict mode:
		Strict mode for scripts: put "use strict"; before any other statements (top of the script).
		Strict mode for functions: put "use strict"; in the function's body before any other statements (top of the function).
			"use strict" can only be applied to functions with simple parameters. "use strict" in functions with rest, default or destructured parameters is a syntax error.
		Strict mode for modules: contents of JS modules are automatically in strict mode, with no statement needed to initiate it.
		Strict mode for classes: all parts of a class's body are strict mode code.

	Changes in strict mode
		changes converting mistakes into errors (as syntax errors or at runtime).
		changes simplifying how variable references are resolved.
		changes simplifying eval and arguments.
		changes making it easier to write "secure" JavaScript.
		changes anticipating future ECMAScript evolution.
		makes it impossible to accidentally create global variables. Assignments that would accidentally create global variables throw ReferenceError
		makes assignments which would silently fail (non-writable data, new property on a non-extensible object, etc) to throw an exception.
		attempts to delete a non-configurable or undeletable property throw TypeError. Also forbids deleting plain names (syntax error).
		requires that function parameter names be unique.
		forbids a 0-prefixed octal literal or octal escape sequence.
		forbids setting properties on primitive values (TypeError).
		Duplicate property names are considered a SyntaxError prior to ES2015. It no longer throws an error.
		simplifies how variable names map to particular variable definitions in the code (allowing some engine optimization).
		prohibits with.
-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- Extra
with keyword (is deprecated): The with statement extends the scope chain for a statement.
	Syntax: with (expresion) statement; // parentheses required
	There are two types of identifiers: qualified and unqualified. Unqualified identifier is one that does not indicate where it comes from. foo -> unquilified; foo.bar -> bar is qualified. Unqualified identifiers are resolved by searching the scope chain for a variable with that name. Qualified identifiers are resolved by searching the prototype chain of an object for a property with that name. The with statement adds the given object to the head of this scope chain during the evaluation of its statement body. Every unqualified name would first be searched within the object (through a in check) before searching in the upper scope chain.
-----------------------------------------------------------------------------------------------------------------------------------------------------
		eval does not introduce new variables into the surrounding scope (eval() function evaluates JavaScript code represented as a string and returns its completion value i.e. eval(script), where script is js code).
		block-scoped function declarations (divergent in sloppy mode) are explicitly specified in strict mode.
		eval and arguments can't be bound or assigned in language syntax.
		doesn't sync indices of the arguments object with each parameter binding (so arguments is like a copy of the params values at the moment the function was called, modifyng the params doesn't modify the arguments object).
		values passed as "this" to a function are not forced into being an object (if unspecified, "this" is undefined, not globalThis).
		it's no longer possible to "walk" the JavaScript stack.
		arguments.callee is no longer supported.
		it has some "Future-proofing JavaScript" with reserved words that aren't actually implemented yet (like interface, package, private, etc).

	Transitioning to strict mode
		You can migrate a codebase to strict mode by first adding "use strict" to a piece of source code, and then fixing all execution errors
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
The "this" keyword
	in methods: a method can use the "this" keyword To access the object which owns that method.
	alone: "this" refers to the global object.
	in functions: "this" refers to the global object.
	in functions in strict mode: "this" is undefined.
	in an event handler: "this" refers to the element that received the event.
	Methods like call(), apply(), and bind() can refer this to any object.

	Explicit binding: when you explicitly set the value of this in a function. For this, call(), apply() and bind() are used.
		call(): Pass in the required object as the first parameter during the function call. The actual parameters are passed after the object.
		apply(): Similar to call() but the arguments are passed as an array.
		bind(): creates a new function with a fixed this. These types of functions are commonly known as bound functions.

	Function Borrowing
		Function borrowing allows us to use the methods of one object on a different object without having to make a copy of that method and maintain it in two separate places.
		It is accomplished through the use of call(), apply() or bind(). e.g. you have a class Dog with the method bark(), and you create a class Cat. After an instance of Cat is made, the Cat object could bark() with the use of:
			call: dogObject.bark.call(catObject)
			apply: dogObject.bark.apply(catObject)
			bind: let catBark = dogObject.bark.bind(catObject); catBark();
		The central benefit is that it allows you to forego inheritance. There’s no reason to force a class to inherit from another if it's only to grant instances of the child class access to a single method. It also keeps you from having to write the same function twice and maintain it in two places.
		The most important practical application of function borrowing is for native methods, specifically, Array.prototype.slice. There are several list-like data structures that aren’t arrays, and it’s useful to be able to treat them as arrays and operate on them as such.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Asyncronous JS
	Asynchronous programming is a technique that lets your program start a task and still be able to be responsive to other events while that task runs, rather than having to wait until that task has finished.

	setTimeout(): runs a function once after the interval of time.
	setInterval(): runs a function repeatedly, starting after the interval of time, then repeating continuously at that interval.

	Event handlers
		a function that will be called, not right away, but whenever the event happens (a specific type of callback).
		event handlers are really a form of asynchronous programming.

	Callbacks
		a function that's passed into another function, with the expectation that it will be called at the appropriate time.
		callback-based code can get hard to understand when the callback itself has to call functions that accept a callback. Because we have to call callbacks inside callbacks, we get a deeply nested function, which is much harder to read and debug. This is sometimes called "callback hell" or the "pyramid of doom". For these reasons, most modern asynchronous APIs don't use callbacks. Instead, the foundation of asynchronous programming in JavaScript is the Promise.

	Promises
		an object returned by an asynchronous function, which represents the current state of the operation. The promise object provides methods to handle the eventual success or failure of the operation.
		another definition: an object that represents the success or failure of a given operation, usually an asynchronous operation.
		Promises are built upon the conventional try/catch model, and thus offers more convenience to developers in writing exception-handling code.
		a promise is created with a function (called: the executor), as argument. Whenever the function was successfully finished, the promise is resolved, if the function was interrupted, threw an error or didn't finish, the promise is rejected.
		Two arguments are passed to the executor:
			a function to be called when the async operation completes: resolve().
			a function to be called when the async operation fails: reject().
		as soon as a promise is created using new Promise() along with a function as argument, this function is executed immediately by the promise.
		States of a promise: since a promise "represents the current state of the operation", it has the following states:
			pending: hasn't finished yet.
			fulfilled: finished as a success.
			rejected: finished as a failure.
		when we call the Promise() constructor, it's set to "pending".
		every promise object has a [[PromiseState]].
		Value of a promise
			when an asynchronous operation completes it is ready with some sort of data to be utilised for further actions.
			a promise's value is set by passing an argument to the resolve() or the reject() function.
				if the operation succeeds, this is the "result" of the operation.
				if it fails, this is the "reason" for the failure.
		The then() method
			available to all promises via Promise.prototype, is used to execute a function when a promise is resolved or rejected.
			it accepts two arguments:
				a function to call once the promise is resolved: onFulfilled().
				a function to call once the promise is rejected: onRejected().
		The executor function
			it has a synchronous nature
			if Promise() is called without an executor, or if that executor is not a function, an exception is thrown.
		every promise object internally maintains two callback queues (which fill when the then() method is used)
			one holding all functions to fire on its resolution.
			one holding all functions to fire on its rejection.

	Chaining
		refers to the notion of subsequently calling then() on the promise returned by then(). Possible since then() returns a new promise.
		this return of a promise by then() is what enables subsequent calls to be made on its invocation expression; and thus chaining.
		if then() is called while its promise is still unsettled, the callbacks are queued internally, after that a new promise is created; its reference saved internally in another queue; and finally returned by the method. this returned promise is given the name derived promise.
		there are 3 options of a return for callbacks:
			Returning a non-promise value: fulfills the corresponding derived promise with that value.
			Throwing an exception: the returned promise is rejected with that reason. Consequently the derived promise is rejected that value.
			Returning a promise: the promise returned by then() abides by the result of this promise (if fulfilled, the derived promise fulfills. if rejected, the derived promise rejects, if still pending, the derived promise is put on pending state).

	Event Loop
		JS has a runtime model based on an event loop, which is responsible for executing the code, collecting and processing events, and executing queued sub-tasks.
		It got its name because of how it's usually implemented, which usually resembles:
												while (queue.waitForMessage()) {
													queue.processNextMessage();
												}
							(queue.waitForMessage() waits synchronously for a message to arrive )
		Runtime understanding (theoretical model, JS engines implement and heavily optimize this):
			Stack
				Function calls form a stack of frames.
				the arguments and local variables may continue to exist, as they are stored outside the stack, so they can be accessed by any nested functions long after their outer function has returned.
			Heap
				objects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.
			Queue (message queue)
				a list of messages to be processed. Each message has an associated function that gets called to handle the message.
				Each message is processed completely before any other message is processed.
				messages are added anytime an event occurs and there is an event listener attached to it.
			Zero delays
				Zero delay doesn't mean the call back will fire-off after zero milliseconds.
				The execution depends on the number of waiting tasks in the queue.
			Several runtimes communicating together
				a web worker or a cross-origin iframe has its own stack, heap, and message queue. Two distinct runtimes can only communicate through sending messages via the postMessage. This method adds a message to the other runtime if the latter listens to message events.
			Never blocking
				the event loop never blocks. Handling I/O is typically performed via events and callbacks, so when the app is waiting for an XHR request to return or an IndexedDB query to return, it can still process other things like user input.
			the event loop basically has one task: connecting the queue with the call stack if the call stack is empty.
		On NodeJS:
			is what allows Node.js to perform non-blocking I/O operations by offloading operations to the system kernel whenever possible.
			event loop's order of operations (each one of these op. are called "phase"):
											   ┌───────────────────────────┐
											┌─>│           timers          │
											│  └─────────────┬─────────────┘		┌──────────────────────────────┐
											│  ┌─────────────┴─────────────┐		│ Each phase has a FIFO queue  │
											│  │     pending callbacks     │		│ of callbacks to execute	   │
											│  └─────────────┬─────────────┘		└──────────────────────────────┘
											│  ┌─────────────┴─────────────┐
											│  │       idle, prepare       │
											│  └─────────────┬─────────────┘      ┌───────────────┐
											│  ┌─────────────┴─────────────┐      │   incoming:   │
											│  │           poll            │<─────┤  connections, │
											│  └─────────────┬─────────────┘      │   data, etc.  │
											│  ┌─────────────┴─────────────┐      └───────────────┘
											│  │           check           │		┌────────────────────────────────────────────┐
											│  └─────────────┬─────────────┘		│ any operation may schedule more operations │
											│  ┌─────────────┴─────────────┐		│ and new events processed in the poll phase │
											└──┤      close callbacks      │		│ are queued by the kernel					 │
											   └───────────────────────────┘		└────────────────────────────────────────────┘
				timers: executes callbacks scheduled by setTimeout() and setInterval().
					A timer specifies the threshold after which a provided callback may be executed.
					will run as early as they can be scheduled after the specified time has passed, however, OS scheduling or the running of other callbacks may delay them.
					Technically, the poll phase controls when timers are executed. When the event loop enters the poll phase it will wait (if queue is empty) for the number of ms remaining until the soonest timer's threshold is reached.
				pending callbacks: executes I/O callbacks deferred to the next loop iteration.
					This phase executes callbacks for some system operations. e.g. some OS want to wait to report errors, this will be queued to execute in the pending callbacks phase.
				idle, prepare: only used internally.
				poll: retrieve new I/O events; execute I/O related callbacks (almost all); node will block here when appropriate.
					The poll phase has two main functions:
						1 Calculating how long it should block and poll for I/O.
						2 Processing events in the poll queue.
					When the event loop enters the poll phase:
						If the poll queue is not empty, the event loop will iterate through its queue of callbacks executing them synchronously.
						If the poll queue is empty but no timer is scheduled:
							If scripts have been scheduled by setImmediate(), it'll end the poll and continue to the check phase.
							If scripts haven't been scheduled by setImmediate(), it'll wait for callbacks to be added to the queue and execute them.
						If the poll queue is empty and a timer is scheduled:
							it'll wrap back to the timers phase to execute those timers' callbacks.
				check: setImmediate() callbacks are invoked here.
					This phase allows a person to execute callbacks immediately after the poll phase has completed.
				close callbacks: some close callbacks.
					If a socket or handle is closed abruptly, the 'close' event will be emitted in this phase.
-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- Extra
https://softwareengineering.stackexchange.com/questions/294346/c-runtime-and-runtime-linking -> nice runtimes explanation

Nodejs documentation:

setTimeout() vs setImmediate()
	setImmediate() is designed to execute a script once the current poll phase completes.
	setTimeout() schedules a script to be run after a minimum threshold in ms has elapsed.
The main advantage to using setImmediate() over setTimeout() is setImmediate() will always be executed before any timers if scheduled within an I/O cycle, independently of how many timers are present.

Understanding process.nextTick()
	process.nextTick() is not technically part of the event loop. Regardless of the current phase of the event loop, the nextTickQueue will be processed after the current operation (defined as: a transition from the C/C++ handler, and handling the JS that needs to be executed) is completed.
	any time you call process.nextTick() in a phase, all callbacks passed to this function will be resolved before the event loop continues.

process.nextTick() vs setImmediate()
	process.nextTick() fires immediately on the same phase
	setImmediate() fires on the following iteration or 'tick' of the event loop
	We recommend developers use setImmediate() in all cases because it's easier to reason about.
	Why use process.nextTick()?
		Allow users to handle errors, cleanup any then unneeded resources, or perhaps try the request again before the event loop continues.
		At times it's necessary to allow a callback to run after the call stack has unwound but before the event loop continues.
-----------------------------------------------------------------------------------------------------------------------------------------------------
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Working with API's
	API's are constructs made available in programming languages to allow developers to create complex functionality more easily. They abstract more complex code away from you, providing some easier syntax to use in its place.
-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- Extra
Library vs API
	A library is a collection of functionality not making up an application of its own, but offered to application software to ease implementing some tasks.
	The way of interacting with that library is defined by some API.
	So there can be multiple version of a library (or implementation, from different vendors) with one same API to interact with them.

Framework vs Library
	The key difference between a library and a framework is "Inversion of Control".
		When calling a method from a library, the developer is in control.
		With a framework, the control is inverted: the framework calls the developer's code.
-----------------------------------------------------------------------------------------------------------------------------------------------------

	JS API's
		client side js has many api's but generally fall into two categories:
			Browser APIs: built into your web browser.
			Third-party APIs: not built into the browser by default, and you have to retrieve their code (or information) from somewhere on the Web.

	How do APIs work?
		Generally api's have common features and similar themes to how they work:
			They are based on objects
				Your code interacts with APIs using JS objects, which serve as containers for the data (properties), and the functionality (methods) it makes available.
			They have recognizable entry points
				When using an API, you should make sure you know where the entry point is for the API.
			They often use events to handle changes in state
			They have additional security mechanisms where appropriate (e.g. some of the modern WebAPIs will only work on pages served over HTTPS).

	Fetching data from the server
		The main API here is the Fetch API. This enables JavaScript running in a page to make an HTTP request to a server to retrieve specific resources.
		In the early days, this general technique was known as Asynchronous JavaScript and XML (Ajax), because it tended to request XML data.

	XMLHttpRequest (XHR)
		objects used to interact with servers.
		used heavily in AJAX programming.
		can be used to retrieve any type of data (not just XML), with protocols other than HTTP.
		If the communication needs to involve receiving event data or message data, use server-sent events through the EventSource interface.
		For full-duplex communication, WebSockets may be a better choice.

	The Fetch API
		considered a modern replacement for XMLHttpRequest.
		it's a simpler API and has more features than XMLHttpRequest.
		uses Request and Response objects.
		the entry point to the Fetch API is a global function called fetch().
		fetch() takes one mandatory argument, the path to the resource you want to fetch.
		fetch() returns a promise (since it's an async api), that resolves to a Response object.
		the response can be formatted into many different object, this are just examples:
			.text(): plain text.
			.json(): a json object.
			.blob(): a blob (Blob is an abbreviation of "Binary Large Object" and can basically be used to represent large file-like objects).
		You can create a request and response directly using the Request() and Response() constructors, but it's uncommon. These are more likely to be created as results of other API actions.
-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- Extra
Web Workers API
	Web Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application.
	A worker is an object that runs a named JS file, that contains the code that will run in the worker thread.
	you can run almost any code you like inside a worker thread. Some exceptions:
		you can't directly manipulate the DOM from inside a worker.
		you can't use some default methods and properties of the window object.
	Data is sent between workers and the main thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler.
	There are a number of different types of workers:
		Dedicated workers: are utilized by a single script. This context is represented by a DedicatedWorkerGlobalScope object.
		Shared workers: can be utilized by multiple scripts running in different windows, IFrames, etc..., as long as they are in the same domain as the worker. These scripts must communicate via an active port.
		Service Workers: essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests and take appropriate action based on whether the network is available, and update assets residing on the server. They also allow access to push notifications and background sync APIs.
	methods are defined in WindowOrWorkerGlobalScope, and made available to workers through their own WorkerGlobalScope-derived contexts:
		DedicatedWorkerGlobalScope for dedicated workers
		SharedWorkerGlobalScope for shared workers
		ServiceWorkerGlobalScope for service workers
-----------------------------------------------------------------------------------------------------------------------------------------------------
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Classes
	template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are unique to classes.

Defining classes
	Classes are in fact "special functions"
	a class can be defined in two ways:
		class declaration: class ClassName {...}
		class expression:
			anonymous class: const ClassName = class {...}
			named class: const ClassName = class ClassName2 {...}
	class declarations have the same temporal dead zone restrictions as "let" or "const" and behave as if they are not hoisted.

Class body
	The body of a class is executed in strict mode even without the "use strict" directive.
	A class element can be characterized by three aspects:
		Kind: Getter, setter, method, or field
		Location: Static or instance
		Visibility: Public or private
	within the body, you can access the object being created through this and access the class that is called with new

Methods
	Methods are defined on the prototype of each class instance and are shared by all instances.

Field declarations
	Class fields are similar to object properties, not variables, so we don't use keywords such as const to declare them.
	the fields can be declared with or without a default value. Fields without default values default to undefined.

Static methods and fields
	The static keyword defines a static method or field for a class. Static properties (fields and methods) are defined on the class itself instead of each instance.

Inheritance
	The "extends" keyword is used in class declarations or class expressions to create a class as a child of another constructor
	The "super" keyword can also be used to call corresponding methods of super class.

Evaluation order
	When a class declaration or class expression is evaluated, its various components are evaluated in the following order:
		1 extends (if present) is first evaluated. It must evaluate to a valid constructor function or null, or a TypeError is thrown.
		2 constructor is extracted (default if not present).
		3 class elements' property keys are evaluated in order of declaration. If the property key is computed, the computed expression is evaluated, with the "this" value set to the "this" value surrounding the class (not the class itself). None of the property values are evaluated yet.
		4 methods and accessors are installed in the order of declaration. Instance methods and accessors are installed on the prototype, and static ones are installed on the class itself. Private instance methods and accessors are saved to be installed on the instance directly later.
		5 The class is now initialized with the prototype specified by extends and implementation specified by constructor. For all steps above, if an evaluated expression tries to access the name of the class, a ReferenceError is thrown because the class is not initialized yet.
		6 The class elements' values are evaluated in the order of declaration:
			For each instance field (public or private), its initializer expression is saved and evaluated during instance creation, at the start of the constructor (for base classes) or immediately before the super() call returns (for derived classes).
			For each static field (public or private), its initializer is evaluated with "this" set to the class itself, and the property is created on the class.
			Static initialization blocks are evaluated with "this" set to the class itself.
		7 The class is now fully initialized and can be used as a constructor function.

Constructor
	special method for creating and initializing an object created with a class (can only be one).
	A constructor can use the super keyword to call the constructor of the super class.
	constructor cannot be async, or generator.
	enables you to provide any custom initialization before any other methods can be called.
	if no constructor is defined, a default constructor will be supplied (if base class, the default is empty, if derived class, the default calls the parent constructor passing along any arguments that were provided).
	Using new on a class goes through the following steps:
		if derived class, constructor body before the super() call is evaluated. This part should not access "this" 'cause it's not yet initialized.
		if derived class, super() call is evaluated, which initializes the parent class through the same process.
		The current class's fields are initialized.
		The constructor body after the super() call (or entire body, if base class) is evaluated.
	methods and the prototype chain are already initialized on "this" before the constructor is executed. However, if those methods use "this", the this will not have been fully initialized yet.
	constructor method may have a return value. Base classes may return anything, derived classes must return an object or undefined, or a TypeError will be thrown.
	If parent class constructor returns an object, it will be used as the "this" value on which class fields of the derived class will be defined. This trick is called "return overriding", it allows a derived class's fields (including private ones) to be defined on unrelated objects.

Different Inheritances
	Extends
		use the keyword "extends".
		Any constructor that can be called with new and has the prototype property can be parent class.
		The prototype property of the ParentClass must be an Object or null.
		extends sets the prototype for both ChildClass and ChildClass.prototype.
		The right-hand side of extends doesn't have to be an identifier, but any expression that evaluates to a constructor.
		The "this" value in the extends expression is the "this" surrounding the class definition
		the base class may return anything from constructor but the derived class must return an object or undefined, or TypeError will be thrown.
		Subclassing built-ins causes non-negligible performance and security impacts. A better way to extend built-ins is to use composition.
	Composition:
		Inheritance often leads to the circle-ellipse problem, because neither type perfectly entails the behavior of the other
		In general it's better to use composition instead.
		Composition means that a class has a reference to an object of another class, and only uses that object as an implementation detail.
		This means more code duplication, but also means that the ChildClass is not strongly coupled to the ParentClass, and does not easily break if the ParentClass is changed, avoiding the semantic issues of built-in subclassing.
	Extending null: extends null was designed to allow easy creation of objects that do not inherit from Object.prototype. However, it's not possible to construct such a class in practice using any constructor implementation that doesn't return an object. Instead, you need to explicitly return an instance from the constructor.
	Extending Object: All JavaScript objects inherit from Object.prototype by default, but the only difference from not writing extends at all is that the constructor itself inherits static methods from Object (although there's no value in inheriting these static methods).
	Extending Built-in classes: Built-in classes are extendable also. but there's no static inheritance in built-ins. Built-in objects have their own static methods, for instance Object.keys, Array.isArray etc. Normally, when one class extends another, both static and non-static methods are inherited. But built-in classes are an exception. They don’t inherit statics from each other.
	Species
		The species pattern lets you override default constructors.
		Symbol.species symbol lets you return a parent object, instead of the child object in some methods.
		Example:
			class MyArray extends Array {
				// Overwrite species to the parent Array constructor
				static get [Symbol.species]() {
					return Array;
				}
			}
			const a = new MyArray(1, 2, 3);
			const mapped = a.map((x) => x * x);
			console.log(mapped instanceof MyArray); // false
			console.log(mapped instanceof Array); // true

Mix-ins
	Abstract subclasses or mix-ins are templates for classes.
	A mixin is a class with methods to be used by other classes without needing to inherit from it, since a class can only inherit from one class.
	A function with a superclass as input and a subclass extending that superclass as output can be used to implement mix-ins:
		Example:
			const calculatorMixin = (Base) =>
				class extends Base {
					calc() {}
				};
			A class that uses these mix-ins can then be written like this:
				class Foo {}
				class Bar extends calculatorMixin(randomizerMixin(Foo)) {}
	Another way to implement mix-ins is with Object.assign():
		// mixin
		let sayHiMixin = {
			sayHi() { alert(`Hello ${this.name}`); }
		};
		// usage:
		class User {
			constructor(name) { this.name = name; }
		}
		Object.assign(User.prototype, sayHiMixin);
		new User("Dude").sayHi(); // Hello Dude!
	Mixins can make use of inheritance inside themselves:
		let sayMixin = {
			say(phrase) { alert(phrase); }
		};
		let sayHiMixin = {
			sayHi() { super.say(`Hello ${this.name}`); }
		}
		Object.setPrototypeOf(sayHiMixin, sayMixin);
		Object.assign(User.prototype, sayHiMixin);
		new User("Dude").sayHi(); // Hello Dude!

Private and protected properties and methods
	In order to hide inner details we’ll use special syntax of the language and conventions.
	Internal and external interface
		In OOP properties and methods are split into two groups:
			Internal interface – methods and properties, accessible from other methods of the class, but not from the outside.
			External interface – methods and properties, accessible also from outside the class.
		An internal interface is used for the object to work, its details use each other. But from the outside it's closed so that no one can reach those. Details are hidden and inaccessible. We can use its features via the external interface.
		In JS theres only public and private object fields (protected doesn't exist, so a convention it's used instead).
	Read-only property
		It sometimes happens that a property must be set at creation time, and never modified.
		To do so, we only need to make getter, but not the setter.
	Protected:
		Not actually implemented in JS, they are emulated.
		Protected properties are usually prefixed with an underscore (_).
		BUT protected fields are inherited, if we inherit nothing prevents us from accessing them from the methods of the new class. So protected fields are naturally inheritable unlike private ones.
	Private (quite recent, not suported in JS engines and requires ):
		Privates should start with #. They are only accessible from inside the class.
		Private fields do not conflict with public ones. We can have both private "#name" and public "name" fields at the same time.
		Private fields are not available as this[name]
		But if we inherit from a class, then we’ll have no direct access to #property. You'll have to rely on getters/setters.

Static initialization blocks
	Static initialization blocks are declared within a class. It contains statements to be evaluated during class initialization.
	allows flexible initialization of static properties, including the evaluation of statements during initialization, while granting access to the private scope.
	Multiple static blocks can be declared, and these can be interleaved with the declaration of static fields and methods (all static items are evaluated in declaration order).
	Syntax: just use ---> static { ... }
	A class can have multiple "static {}" initialization blocks in its body. These are evaluated, along with any interleaved static field initializers, in the order they are declared.
	Any static initialization of a super class is performed first, before that of its sub classes.
	The scope of the variables declared inside the static block is local to the block ("var" declarations are not hoisted).
	"this" inside a static block refers to the constructor of the class.
	super.property can be used to access static properties of the super class.
	The statements are evaluated synchronously. You cannot use await or yield in this block.
	initialization blocks can refer to field values above it, but not below it.

instanceof operator:
	The instanceof operator allows to check whether an object belongs to a certain class. It also takes inheritance into account.
	It returns true if obj belongs to the Class or a class inheriting from it (therefor being able to be an instance of multiple classes, like arrays wich are instanceof Array && instaceof Object).
	by the logic of instanceof, the prototype actually defines the type, NOT the constructor function (so changing the prototype of a class after an instance was created will lead to obj instanceof Class returning false).
	The algorithm of "instanceof":
		If there’s a static method Symbol.hasInstance, then just call it: Class[Symbol.hasInstance](obj). It should return either true or false.
		If there's no Symbol.hasInstance, obj instanceof Class checks whether Class.prototype is equal to one of the prototypes in the obj prototype chain. if any answer is true, return true, otherwise, if we reached the end of the chain, return false.
	there’s also a method objA.isPrototypeOf(objB), (true if objA is somewhere in the chain of prototypes for objB), so "obj instanceof Class" can be rephrased as Class.prototype.isPrototypeOf(obj).
	Bonus: toString as replacement of insatnceof
		Symbol.toStringTag: The behavior of Object.toString can be customized using a special object property Symbol.toStringTag
			let user = { [Symbol.toStringTag]: "Pikachu" };
			{}.toString.call(user) ); // [object Pikachu]
		So we have “typeof on steroids” that not only works for primitives, but also for built-in objects and can even be customized.
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Iterators
	An iterable is something that can be iterated over.
	An iterator is an object that performs iteration over a sequence. In JS, is an object that implements the iterator protocol.
	Being iterable doesn't always has to do with the default setup in JavaScript, by implementing the iterable protocol you can make a non-iterable data type iterable. You define an @@iterator method on it which, when called, returns an iterator object following the iterator protocol.
	The interpreter uses this iterator object to perform iteration over the given data type.
	Iterator Protocol:
		set of rules which must be obeyed by an object in order for it to be called an iterator.
			the object must have a next() method.
			the next() method shall return an object with the following two properties:
				done: a Boolean value indicating whether it has reached its last value.
				value: holds the next value in a given sequence.
	Itrator object:
		you call iter.next() to get the next value in an object {value: x, done: false}.
		Once finished, you still need to iterate once more to be done -> {value: undefined, done:true} THE LAST VALUE WILL NOT GIVE done: true.
		subsequent calls of iter.next() keep returning the same object as the last one -> {value: undefined, done:true}.
	@@iterator (or [Symbol.iterator]()):
		Many data classes in JavaScript have their own defined mechanism to create iterator objects.
		This mechanism is the @@iterator() method. Classes define an @@iterator() method that returns an iterator object for those classes instances.
	Any construct that requires an iterable such as the for...of loop or the spread operator ..., calls the @@iterator() method defined on the iterable. This is a convention set by ECMAScript 6.
-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- Extra: Exercise
Construct a function makeIterator() that takes in an array and returns an iterator to iterate over it.
-----------------------------------------------------------------------------------------------------------------------------------------------------
first working answer:
function makeIterator(arr) {
	let it = {index: 0,
			  response(v, d) {return {value:v, done:d}}
			 };
	function next(){
		try {
			let ret = this.response(arr[this.index], false);
			this.index += 1;
			return ret;
		} catch (e) {
			return this.response(undefined, true);
		}
	}
	it.next = next;
	return it;
}

https://www.codeguage.com/courses/advanced-js/iteration-iterators -> answer:
function makeIterator(arr) {
	var i = 0;
	return {
		next: function() {
			if (i > arr.length - 1)
				return {value: undefined, done: true}
			return {value: arr[i++], done: false}
		}
	}
}
-----------------------------------------------------------------------------------------------------------------------------------------------------

Iterables
	Any object that conforms to the iterable protocol is considered to be an iterable.
	The iterable protocol states that the object must have an @@iterator() method which returns an iterator (following the iterator protocol).
	Knowing what iterables are, it's better to say that the spread operator takes an iterable and converts it into individual elements.
		First it calls @@iterator() and gets an iterator.
		Then it uses it to retrieve the elements of the iterable one-by-one until done property is false.

Generators
	Generators are functions that return iterators to lazily generate an iterable sequence. The idea is to NOT create the desired sequence all at once, but rather generate it element-by-element, hence the "lazily generate".
	Example:
		function positiveInts(n) {
			var i = 1;
			var max = (n < 1 || typeof n !== "number") ? 1 : n;
			return {
				next: function() {
					if (i > max) return {value: undefined, done: true}
					return {value: i++, done: false}
				}
			}
		}
		This generator doesn't allow for direct iteration on the sequence it defined ('cause it doesn't have an @@iterator method), but it helps understand the idea.
	A generator simply defines an iterable sequence with the help of an iterator object. If a generator doesn't operate on an iterator then, by the specification, it isn't a generator.
	Generators in JS:
		With ES6, JS provides a bunch of tools and convenient syntax to create generators that bring on a new model of execution into the language.
		JavaScript introduces a special type of function: generator function (created with an asterisk). e.g: fuction* funcName() {...}
		Within the function body you use the "yield" keyword. This is used to pause and resume a generator function. The "yield" keyword basically defines a value in the iterable sequence defined by the generator. Each yielded value is a value of the sequence, in the order it appears in the generator. e.g:
			function* seq() {yield 1; yield 2; yield 3;}
			let s = seq();
			s.next() // {value: 1, done: false}
			...
			s.next() // {value: undefined, done: true}
		This creates an iterable sequence, so the iterator returned by function* x() has the @@iterator method defined.
		How it works:
			The interpreter realises that it is a generator function's call and likewise returns an iterator right away (the body is not executed).
			This returned iterator runs over the yield values one-by-one each time its next() method is called.
			When the next() method is called on the iterator, execution begins inside the generator and goes upto the next yield keyword, at which point, it pauses (this can be checked by adding a console.log() before every yield an it will only be printed after next() is called).
			The moment yield is encountered, execution pauses, this point is saved internally within the generator function.
			It continues until the function ends, and then the value property of the to-be-returned object by .next() is set to undefined and since the function has completed i.e we are out of yield, done is set to true.
			Basically:
				The next() method serves to resume execution inside a generator.
				The yield keyword serves to pause execution inside a generator.
		Arguments to next() - "yield" taking values
			Each time an argument is provided to .next(), it replaces the "whole corresponding yield expression" with that argument. Since it's a yield expression it'll only work after the first .next(), since the first one doesn't start from a yield but the beginning of the function. eg:
				var x; function* gen() { x = yield 30; }
				gen().next() -> {value: 30, done: false }
				.next(10) -> REPLACES THE WHOLE YIELD EXPRESSION function* gen() { x = ~~yield 30~~ 10; } -> x === 10 after the second .next()
	Other methods beside next(): return() & throw()
		The return() method simply returns the iterator with a given value. Returning means that we are done iterating, so done is set to true. No matter how long the sequence remains, it is terminated with the value provided to the method.
		The throw() method simply resumes execution inside the generator and throws an error in there, where the corresponding yield dwells. So throw() resumes execution and acts as if a throw keyword (with the argument passed, undefined if no argument is used) is put in the location where the previous yield expression. If there's a try/catch to catch that error, it continues to work, otherwise the generator is closed (done: true).
	Delegating generators
		yield* keyword: it's just syntactic sugar to simplify working with an iterable. e.g: arr[1,2,3] yield* arr; (like ... but with yield).
		The yield* keyword allows for the use of the iterator returned by a generator inside another generator, this is called generator delegation.
		Example:
			function* positiveInts(n) {// normal for loop to return positive ints up to n}
			function* negativeInts(n) {// normal for loop to return negative ints up to -n}
			function* seq() {yield* positiveInts(5); yield* negativeInts(5);} -> 1 2 3 4 5 -1 -2 -3 -4 -5, {value: undefined, done:true}
*****************************************************************************************************************************************************


*****************************************************************************************************************************************************
Modules
	Modules encapsulate code and exposes all of it to other files. Generally used to break code into separate files to make it more maintainable.
	A module may contain a class or a library of functions for a specific purpose.
	Basically a module is just a file. One script is one module.

CommonJS Modules (normally used in backend with node, although node supports ESModules)
	the original way to package JavaScript code for Node.js.
	Sometimes these modules will be written with a .cjs extension.
	the js file has a module object with info about the file itself. Within that object it's the exports property.
	to export a function/variable just add it to the "module.exports" object (e.g. module.exports.someFunction = someFunction).
		if theres only one thing to export you could just set the module.exports property to be that one thing (the default export).
	to import a function/variable the "require('path')" is used (e.g. let exports = require('path/to/file.js'); exports.someFunction()).
	to import a function/variable directly without the exports object the destructure method is used: const {someFunction} = require('path');
		if theres only one thing to import the curly braces are skipped (the default import).
	exports can be renamed with the following syntax:
		const {someFunction: someOtherFunction} = require('path');
	How does require work?
		The module loading mechanism in Node.js is caching the modules on the first require call. So every time you use requre('path') the same instace is returned (so modules are singleton-like and have the same state across the app).
		If the identifier passed to require() isn't a native module or a file reference (like /, ../, ./, etc), then node'll look for installed modules.

ESModules (normally used in frontend)
	a standard that was introduced with ES6 (2015).
	Sometimes these modules will be written with a .mjs extension.
	Modules can load each other and use the keywords "export" and "import" to interchange functionality:
		export: labels variables and functions that should be accessible from outside the current module.
		import: allows the import of functionality exported from other modules.
	Syntax
		export: export function/variable
		import: import {function/variable} from 'path'
	The "import" loads the module by path relative to the current file, or absolute if it starts with "/...".
	IMPORTANT: Modules work only via HTTP(s), not locally.
	Core features
		Modules always work in strict mode.
		Each module has its own top-level scope. Modules should export what they want to be accessible from outside and import what they need.
			Extra: In the browser you can make a variable window-level global by explicitly assigning it to a window property, e.g. window.user = "John". Then all scripts will see it, both with type="module" and without it.
		A module code is evaluated only the first time when imported.
		import.meta
			The object import.meta contains the information about the current module.
			Its content depends on the environment. In the browser, it contains the URL of the script.
		In a module, “this” is undefined.
	Browser specific features
		Module scripts are deferred in browsers
			downloading external modules doesn’t block HTML processing, they load in parallel with other resources.
			module scripts wait until the HTML document is fully ready and then runs.
			relative order is maintained: scripts that go first in the document, execute first.
		Async works on inline scripts (for non-module scripts, the async attribute only works on external scripts).
		import must get either a relative or absolute URL. Modules without any path are called “bare” modules (and aren't allowed)
		Compatibility: “nomodule”
			Old browsers do not understand type="module". Scripts of an unknown type are just ignored.
			It’s possible to provide a fallback using the nomodule attribute.
		External scripts that are fetched from another origin require CORS headers, otherwise, the script won't execute. (see extra below for CORS)
	import & export
		you can export before the declaration (e.g. export function x(){}) or separetly from the declaration (e.g. function x(){} export {x}).
		"as" keyword:
			import {function} as x from 'path' -> allows to use function as x (e.g. x()).
			export {function} as x -> allows to be exported as x.
		you can avoid to import explicitly (curly braces {/*imports*/}) by using * and the as keyword (e.g. import * as <object> from 'path').
		export default function -> import it without curly braces (there may be only one export default per file). import needs curly braces for named exports but doesn’t need them for default exports. If this is done, since the default is set at export, the name can be anything: import hi from 'path';
		default
			export default alternative: export {function as default};
			if theres multiple exports an one default export then you import like: import {default as Class, function, function2} from 'path';
			if imported with *: import * as x from 'path'; x.default contains the default export.
		Re-export
			“Re-export” syntax export ... from ... allows to import things and immediately export them (possibly under another name).
			helpful to allow exports from a single file all together: import {functiona, functinob, functionc} from 're/export/file.js' -> where functiona is declared in filea, functionb in fileb, etc.
				named exports: export {x} from 'path';
				default exports: export {default as x} from 'path';
	Dynamic imports
		The import(module) expression loads the module and returns a promise that resolves into a module object that contains all its exports. It can be called from any place in the code.
		Dynamic imports work in regular scripts, they don’t require script type="module".
		Although import() looks like a function call, it’s a special syntax that just happens to use parentheses.
		Examples:
			let {f1, f2} = await import('./functions.js');
			import('path').then(obj => <module object>).catch(err => <loading error, e.g. if no such module>);
			if its an "export default":
				let obj = await import('./module.js');
				let f = obj.default;

-----------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------- Extra: CORS
What is CORS
	Cross-origin requests (those sent to another domain (even a subdomain) or protocol or port) require special headers from the remote side.
	That policy is called “CORS”: Cross-Origin Resource Sharing.

Safe requests
	For a request to be consider safe it must satisfy some conditinos (see: https://javascript.info/fetch-crossorigin#safe-requests).
	If a request is cross-origin, the browser always adds the Origin header to it.
	The server can inspect the Origin and, if it agrees to accept such a request, add a special header Access-Control-Allow-Origin to the response. That header should contain the allowed origin or a star *. Then the response is successful, otherwise it’s an error.
	For cross-origin request, by default JavaScript may only access so-called “safe” response headers, accessing any other response header causes an error.
	To grant JavaScript access to any other response header, the server must send the Access-Control-Expose-Headers header. It contains a comma-separated list of unsafe header names that should be made accessible.

"Unsafe" Requests
	The essential difference is that safe requests were doable since old times, while unsafe were impossible for browsers for a long time.
	So to avoid misunderstandings, any “unsafe” request (that couldn’t be done in the old times) the browser doesn't make them right away. First it sends a so-called “preflight” request, to ask for permission.
	A preflight request uses the method OPTIONS, no body and three headers.
	If the server agrees to serve the requests, then it should respond with empty body, status 200 and some headers:
		Access-Control-Allow-Origin: must be * or the requesting origin.
		Access-Control-Allow-Methods must have the allowed method.
		Access-Control-Allow-Headers must have a list of allowed headers.
		Access-Control-Max-Age: may specify a number of seconds to cache the permissions (so browser won’t have to send a preflight for subsequent requests that satisfy given permissions).
	Note: Preflight request occurs “behind the scenes”, it’s invisible to JavaScript.
-----------------------------------------------------------------------------------------------------------------------------------------------------
*****************************************************************************************************************************************************














